<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Group Swipe ‚Ä¢ Food Finder</title>
  <meta name="theme-color" content="#ff6b6b" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="icon" href="/food_finder_favicon.png" type="image/png" />
  <link rel="apple-touch-icon" href="/food_finder_favicon.png" />
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <header class="app-header">
    <div class="header-content">
      <button class="filter-icon" onclick="window.location.href='/'" title="Back to Home">‚Üê</button>
      <h1 class="header-title">Group Swipe</h1>
      <div style="width:40px"></div>
    </div>
  </header>

  <div class="container">
    <section class="group-mode-hero">
      <div class="group-mode-content">
        <h2 class="group-mode-title">Can't Decide? Swipe Together! üíö</h2>
        <p class="group-mode-description">Create a room, share the code, and swipe to find matches.</p>
      </div>
    </section>

    <section style="padding: 0 1rem 2rem; max-width: 700px; margin: 0 auto;">
      <div class="card" id="step-setup">
        <h3>Create or Join</h3>
        
        <!-- Location Status -->
        <div id="location-status" style="margin-bottom: 1.5rem; padding: 0.75rem; background: #f8f9fa; border-radius: 12px; font-size: 0.9rem; color: #666;">
          <span id="location-text">üìç Getting your location...</span>
        </div>
        
        <div class="swipe-form">
          <label>Group Size</label>
          <div class="number-input-container">
            <button onclick="decreaseSwipeGroupSize()" class="number-btn">‚àí</button>
            <input type="number" id="swipe-group-size" min="2" max="10" value="2" readonly>
            <button onclick="increaseSwipeGroupSize()" class="number-btn">+</button>
          </div>
          
          <!-- Filters Section -->
          <div style="margin: 1.5rem 0;">
            <button onclick="toggleFilters()" class="modern-btn tertiary" style="width: 100%; margin-bottom: 1rem;">
              <span id="filters-toggle-icon">‚ñº</span> <span id="filters-toggle-text">Add Filters (Optional)</span>
            </button>
            
            <div id="filters-section" style="display: none; padding: 1rem; background: #f8f9fa; border-radius: 12px;">
              <!-- Cuisine -->
              <div class="filter-group" style="margin-bottom: 1.5rem;">
                <h4 style="margin: 0 0 0.75rem 0; font-size: 0.95rem; color: #2c3e50;">Cuisine</h4>
                <div class="chip-group">
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'italian')">Italian</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'chinese')">Chinese</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'japanese')">Japanese</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'korean')">Korean</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'thai')">Thai</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'mexican')">Mexican</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'indian')">Indian</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'cuisine', 'vietnamese')">Vietnamese</button>
                </div>
              </div>
              
              <!-- Dietary -->
              <div class="filter-group" style="margin-bottom: 1.5rem;">
                <h4 style="margin: 0 0 0.75rem 0; font-size: 0.95rem; color: #2c3e50;">Dietary</h4>
                <div class="chip-group">
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'dietary', 'vegetarian')">Vegetarian</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'dietary', 'vegan')">Vegan</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'dietary', 'halal')">Halal</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'dietary', 'gluten-free')">Gluten-Free</button>
                  <button class="filter-chip" onclick="toggleGroupFilterChip(this, 'dietary', 'keto')">Keto</button>
                </div>
              </div>
              
              <!-- Price Range -->
              <div class="filter-group" style="margin-bottom: 1.5rem;">
                <h4 style="margin: 0 0 0.75rem 0; font-size: 0.95rem; color: #2c3e50;">Price Range</h4>
                <div class="slider-container">
                  <input type="range" id="group-price-slider" min="1" max="4" step="1" value="2" onchange="updateGroupPriceValue()">
                  <span id="group-price-value">$$ Moderate</span>
                </div>
              </div>
              
              <!-- Distance -->
              <div class="filter-group">
                <h4 style="margin: 0 0 0.75rem 0; font-size: 0.95rem; color: #2c3e50;">Max Distance</h4>
                <div class="slider-container">
                  <input type="range" id="group-distance-slider" min="0.5" max="10" step="0.5" value="5" onchange="updateGroupDistanceValue()">
                  <span id="group-distance-value">5 km</span>
                </div>
              </div>
            </div>
          </div>
          
          <button onclick="createSwipeRoom()" class="modern-btn primary" id="create-room-btn">Create Room</button>
        </div>
        <div class="swipe-form" style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #e9ecef;">
          <label>Or Join Existing Room</label>
          <input type="text" id="join-room-code" placeholder="Enter room code" maxlength="6" style="text-transform: uppercase;">
          <button onclick="joinSwipeRoom()" class="modern-btn secondary">Join Room</button>
        </div>
      </div>

      <div class="card" id="step-waiting" style="display:none; text-align:center;">
        <h3>Waiting for Players</h3>
        <div class="room-code-display">
          <p class="room-code-label">Room Code</p>
          <p class="room-code" id="display-room-code">ABC123</p>
          <button onclick="copyRoomCode()" class="modern-btn secondary small">Copy Code</button>
        </div>
        <p>Participants: <span id="participant-count">1</span>/<span id="max-participants">2</span></p>
        <button onclick="startSwiping()" class="modern-btn primary" id="start-swipe-btn" style="display:none;">Start Swiping</button>
      </div>

      <div class="card" id="step-swiping" style="display:none;">
        <div class="swipe-header" style="padding:0; border:none;">
          <div class="swipe-progress"><span id="swipe-progress-text">0 / 0</span></div>
        </div>
        <div class="swipe-content-swipe">
          <div class="swipe-stack" id="swipe-stack"></div>
          <div class="swipe-actions">
            <button onclick="swipePass()" class="swipe-btn pass-btn"><span>‚úï</span><span class="swipe-label">Pass</span></button>
            <button onclick="swipeLike()" class="swipe-btn like-btn"><span>‚ô•</span><span class="swipe-label">Like</span></button>
          </div>
        </div>
      </div>

      <div class="card" id="step-matches" style="display:none;">
        <h3>üéâ Matches Found!</h3>
        <div class="matches-list" id="matches-list"></div>
        <div class="match-actions">
          <button onclick="randomPickMatch()" class="modern-btn secondary">üé≤ Random Pick</button>
          <button onclick="startMatchVoting()" class="modern-btn primary">üó≥Ô∏è Vote on Matches</button>
          <button onclick="retrySwiping()" class="modern-btn tertiary">üîÑ Get More Options</button>
        </div>
      </div>
    </section>
  </div>

  <script>
    // API base detection
    const getApiBaseUrl = () => {
      const port = window.location.port;
      if (port && port !== '3000' && (port === '5502' || port.startsWith('55'))) {
        return 'http://localhost:3000';
      }
      return '';
    };
    const API_BASE = getApiBaseUrl();

    let userId = null;
    let userLocation = null; // human-readable
    let userCoordinates = null; // { lat, lng }
    function getUserId() {
      if (!userId) {
        userId = localStorage.getItem('foodFinderUserId');
        if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('foodFinderUserId', userId);
        }
      }
      return userId;
    }

    // Geolocation ‚Üí reverse geocode helper
    async function getCurrentLocation() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
        navigator.geolocation.getCurrentPosition(async (pos) => {
          try {
            const { latitude, longitude } = pos.coords;
            userCoordinates = { lat: latitude, lng: longitude };
            // Reverse geocode via API
            const r = await fetch(`${API_BASE}/api/geocode?lat=${latitude}&lng=${longitude}`);
            if (r.ok) {
              const data = await r.json();
              userLocation = data.formatted_address || data.city || `${latitude.toFixed(3)}, ${longitude.toFixed(3)}`;
            } else {
              userLocation = `${latitude.toFixed(3)}, ${longitude.toFixed(3)}`;
            }
            resolve({ userLocation, userCoordinates });
          } catch (e) {
            reject(e);
          }
        }, (err) => reject(err), { enableHighAccuracy: true, timeout: 8000, maximumAge: 60000 });
      });
    }

    // Get location and update UI
    (async () => {
      const statusEl = document.getElementById('location-text');
      try {
        statusEl.textContent = 'üìç Getting your location...';
        await getCurrentLocation();
        statusEl.textContent = `üìç ${userLocation || 'Location ready'}`;
        statusEl.style.color = '#4CAF50';
      } catch (e) {
        statusEl.textContent = '‚ö†Ô∏è Location not available - using default';
        statusEl.style.color = '#ff9800';
        console.warn('Location not available:', e);
      }
    })();

    // Minimal swipe state
    let swipeData = {
      roomCode: null,
      groupSize: 2,
      participants: [],
      currentRestaurants: [],
      currentIndex: 0,
      swiped: []
    };

    // Filter state
    let groupFilters = {
      cuisine: [],
      dietary: [],
      price_range: 'moderate',
      distance: 5
    };

    // Swipe animation state
    let dragState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      currentX: 0,
      currentY: 0,
      card: null
    };

    function increaseSwipeGroupSize() {
      const input = document.getElementById('swipe-group-size');
      const value = parseInt(input.value) || 2;
      if (value < 10) input.value = value + 1;
    }
    function decreaseSwipeGroupSize() {
      const input = document.getElementById('swipe-group-size');
      const value = parseInt(input.value) || 2;
      if (value > 2) input.value = value - 1;
    }

    function showStep(idToShow) {
      const steps = ['step-setup','step-waiting','step-swiping','step-matches'];
      steps.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = (id === idToShow) ? 'block' : 'none';
      });
    }

    function updateSwipeProgress() {
      const total = swipeData.currentRestaurants.length;
      const current = Math.min(swipeData.currentIndex, total);
      const el = document.getElementById('swipe-progress-text');
      if (el) el.textContent = `${current} / ${total}`;
    }

    function createSwipeCard(restaurant) {
      const card = document.createElement('div');
      card.className = 'swipe-card';
      const bg = restaurant.images && restaurant.images[0] && restaurant.images[0].photo_reference
        ? `${API_BASE}/api/photo?photo_reference=${restaurant.images[0].photo_reference}&maxwidth=800`
        : (restaurant.images && restaurant.images[0] && restaurant.images[0].url) || '';
      card.innerHTML = `
        <div class="swipe-card-image" style="background-image:url('${bg}')">
          ${restaurant.opening_hours && restaurant.opening_hours.open_now ? '<div class="open-badge">Open now</div>' : ''}
        </div>
        <div class="swipe-card-content">
          <h3>${restaurant.name || 'Restaurant'}</h3>
          <div class="swipe-card-rating"><span class="rating-stars">‚òÖ</span> ${restaurant.rating || '‚Äî'} (${restaurant.user_ratings_total || 0})</div>
          <p class="swipe-card-location">${restaurant.vicinity || restaurant.formatted_address || ''}</p>
        </div>
        <div class="swipe-overlay swipe-overlay-like">LIKE</div>
        <div class="swipe-overlay swipe-overlay-pass">PASS</div>
      `;
      
      // Add drag/swipe event listeners
      setupSwipeHandlers(card);
      return card;
    }

    function setupSwipeHandlers(card) {
      let startX = 0, startY = 0, currentX = 0, currentY = 0, isDragging = false;

      const handleStart = (clientX, clientY) => {
        if (isDragging) return;
        isDragging = true;
        startX = clientX;
        startY = clientY;
        card.style.transition = 'none';
      };

      const handleMove = (clientX, clientY) => {
        if (!isDragging) return;
        currentX = clientX - startX;
        currentY = clientY - startY;
        
        // Calculate rotation (max 15 degrees)
        const rotation = currentX * 0.1;
        const opacity = 1 - Math.abs(currentX) / 400;
        
        // Update card transform
        card.style.transform = `translateX(${currentX}px) translateY(${currentY}px) rotate(${rotation}deg)`;
        card.style.opacity = Math.max(0.5, opacity);
        
        // Show overlay feedback
        const likeOverlay = card.querySelector('.swipe-overlay-like');
        const passOverlay = card.querySelector('.swipe-overlay-pass');
        
        if (currentX > 50) {
          // Swiping right (like)
          likeOverlay.style.opacity = Math.min(1, currentX / 200);
          passOverlay.style.opacity = 0;
        } else if (currentX < -50) {
          // Swiping left (pass)
          passOverlay.style.opacity = Math.min(1, Math.abs(currentX) / 200);
          likeOverlay.style.opacity = 0;
        } else {
          likeOverlay.style.opacity = 0;
          passOverlay.style.opacity = 0;
        }
      };

      const handleEnd = () => {
        if (!isDragging) return;
        isDragging = false;
        
        const threshold = 100; // pixels to trigger swipe
        card.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
        
        if (currentX > threshold) {
          // Swipe right - LIKE
          card.style.transform = `translateX(1000px) rotate(30deg)`;
          card.style.opacity = '0';
          setTimeout(() => swipeLike(), 300);
        } else if (currentX < -threshold) {
          // Swipe left - PASS
          card.style.transform = `translateX(-1000px) rotate(-30deg)`;
          card.style.opacity = '0';
          setTimeout(() => swipePass(), 300);
        } else {
          // Snap back to center
          card.style.transform = 'translateX(0) translateY(0) rotate(0deg)';
          card.style.opacity = '1';
          card.querySelector('.swipe-overlay-like').style.opacity = '0';
          card.querySelector('.swipe-overlay-pass').style.opacity = '0';
        }
        
        currentX = 0;
        currentY = 0;
      };

      // Touch events
      card.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleStart(touch.clientX, touch.clientY);
      }, { passive: false });

      card.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleMove(touch.clientX, touch.clientY);
      }, { passive: false });

      card.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleEnd();
      }, { passive: false });

      // Mouse events
      card.addEventListener('mousedown', (e) => {
        e.preventDefault();
        handleStart(e.clientX, e.clientY);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      });

      const handleMouseMove = (e) => {
        handleMove(e.clientX, e.clientY);
      };

      const handleMouseUp = () => {
        handleEnd();
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }

    function renderSwipeCard() {
      const stack = document.getElementById('swipe-stack');
      if (!stack) return;
      stack.innerHTML = '';
      const r = swipeData.currentRestaurants[swipeData.currentIndex];
      if (!r) return;
      stack.appendChild(createSwipeCard(r));
      updateSwipeProgress();
      prefetchNextImages(3);
      maybeFetchMoreSoon();
    }

    // Filter functions
    function toggleFilters() {
      const section = document.getElementById('filters-section');
      const icon = document.getElementById('filters-toggle-icon');
      const text = document.getElementById('filters-toggle-text');
      if (section.style.display === 'none') {
        section.style.display = 'block';
        icon.textContent = '‚ñ≤';
        text.textContent = 'Hide Filters';
      } else {
        section.style.display = 'none';
        icon.textContent = '‚ñº';
        text.textContent = 'Add Filters (Optional)';
      }
    }

    function toggleGroupFilterChip(btn, category, value) {
      btn.classList.toggle('active');
      if (!groupFilters[category]) groupFilters[category] = [];
      const index = groupFilters[category].indexOf(value);
      if (index > -1) {
        groupFilters[category].splice(index, 1);
      } else {
        groupFilters[category].push(value);
      }
    }

    function updateGroupPriceValue() {
      const slider = document.getElementById('group-price-slider');
      const value = parseInt(slider.value);
      const display = document.getElementById('group-price-value');
      const priceMap = { 1: '$ Budget', 2: '$$ Moderate', 3: '$$$ Expensive', 4: '$$$$ Luxury' };
      display.textContent = priceMap[value] || '$$ Moderate';
      const priceRangeMap = { 1: 'budget', 2: 'moderate', 3: 'expensive', 4: 'luxury' };
      groupFilters.price_range = priceRangeMap[value] || 'moderate';
    }

    function updateGroupDistanceValue() {
      const slider = document.getElementById('group-distance-slider');
      const value = parseFloat(slider.value);
      const display = document.getElementById('group-distance-value');
      display.textContent = `${value} km`;
      groupFilters.distance = value;
    }

    async function createSwipeRoom() {
      // Ensure location is available
      if (!userLocation && !userCoordinates) {
        const statusEl = document.getElementById('location-text');
        statusEl.textContent = 'üìç Getting location...';
        statusEl.style.color = '#666';
        try {
          await getCurrentLocation();
          statusEl.textContent = `üìç ${userLocation || 'Location ready'}`;
          statusEl.style.color = '#4CAF50';
        } catch (e) {
          const proceed = confirm('Location not available. Continue anyway? (Results may be less relevant)');
          if (!proceed) return;
        }
      }

      try {
        const btn = document.getElementById('create-room-btn');
        btn.disabled = true;
        btn.textContent = 'Creating...';
        
        const groupSize = parseInt(document.getElementById('swipe-group-size').value) || 2;
        swipeData.groupSize = groupSize;
        
        const filters = {
          cuisine: groupFilters.cuisine,
          dietary: groupFilters.dietary,
          price_range: groupFilters.price_range,
          distance: groupFilters.distance
        };
        
        const res = await fetch(`${API_BASE}/api/swipe/create-room`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ groupSize, userLocation, userCoordinates, filters })
        });
        if (!res.ok) throw new Error('Create failed ' + res.status);
        const data = await res.json();
        swipeData.roomCode = data.roomCode;
        document.getElementById('display-room-code').textContent = data.roomCode;
        document.getElementById('max-participants').textContent = groupSize;
        await joinSwipeRoomInternal(data.roomCode);
        showStep('step-waiting');
        pollForParticipants();
      } catch (e) {
        console.error(e);
        alert('Failed to create room: ' + (e.message || 'Unknown error'));
      } finally {
        const btn = document.getElementById('create-room-btn');
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Create Room';
        }
      }
    }

    async function joinSwipeRoom() {
      const code = (document.getElementById('join-room-code').value || '').trim().toUpperCase();
      if (!code) return;
      await joinSwipeRoomInternal(code);
      swipeData.roomCode = code;
      document.getElementById('display-room-code').textContent = code;
      showStep('step-waiting');
      pollForParticipants();
    }

    async function joinSwipeRoomInternal(roomCode) {
      const res = await fetch(`${API_BASE}/api/swipe/join-room`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ roomCode, userId: getUserId() })
      });
      if (!res.ok) throw new Error('Join failed ' + res.status);
      const data = await res.json();
      swipeData.participants = data.participants || [];
      document.getElementById('participant-count').textContent = swipeData.participants.length;
      document.getElementById('max-participants').textContent = data.maxParticipants || swipeData.groupSize;
      const startBtn = document.getElementById('start-swipe-btn');
      if (startBtn) startBtn.style.display = 'block';
    }

    async function pollForParticipants() {
      try {
        const res = await fetch(`${API_BASE}/api/swipe/check-matches`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode: swipeData.roomCode })
        });
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data.participants)) {
            swipeData.participants = data.participants.map(p => p.userId || p);
            document.getElementById('participant-count').textContent = swipeData.participants.length;
          }
        }
      } catch {}
      setTimeout(pollForParticipants, 3000);
    }

    async function startSwiping() {
      try {
        const res = await fetch(`${API_BASE}/api/swipe/get-restaurants`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode: swipeData.roomCode, userId: getUserId(), userLocation, userCoordinates })
        });
        if (!res.ok) throw new Error('Get restaurants failed ' + res.status);
        const data = await res.json();
        swipeData.currentRestaurants = data.restaurants || [];
        swipeData.currentIndex = 0;
        showStep('step-swiping');
        renderSwipeCard();
      } catch (e) {
        console.error(e); alert('Failed to start swiping.');
      }
    }

    async function recordSwipe(liked) {
      const r = swipeData.currentRestaurants[swipeData.currentIndex];
      if (!r) return;
      try {
        await fetch(`${API_BASE}/api/swipe/record-swipe`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode: swipeData.roomCode, userId: getUserId(), restaurantId: r.place_id || r.id, liked })
        });
      } catch {}
    }

    function swipeLike() {
      recordSwipe(true);
      swipeData.currentIndex++;
      if (swipeData.currentIndex >= swipeData.currentRestaurants.length) {
        checkSwipeMatches();
      } else {
        renderSwipeCard();
      }
    }
    function swipePass() {
      recordSwipe(false);
      swipeData.currentIndex++;
      if (swipeData.currentIndex >= swipeData.currentRestaurants.length) {
        checkSwipeMatches();
      } else {
        renderSwipeCard();
      }
    }

    async function checkSwipeMatches() {
      try {
        const res = await fetch(`${API_BASE}/api/swipe/check-matches`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode: swipeData.roomCode })
        });
        if (!res.ok) throw new Error('Check matches failed ' + res.status);
        const data = await res.json();
        if (Array.isArray(data.matches) && data.matches.length) {
          showStep('step-matches');
          showSwipeMatches(data.matches);
        } else {
          // no matches yet; show matches step with empty state
          showStep('step-matches');
          showSwipeMatches([]);
        }
      } catch (e) {
        console.error(e);
        alert('Failed to check matches.');
      }
    }

    function showSwipeMatches(matches) {
      const list = document.getElementById('matches-list');
      if (!list) return;
      if (!matches || !matches.length) {
        list.innerHTML = '<div class="no-matches">No matches yet. Try again to get more options.</div>';
        return;
      }
      list.innerHTML = matches.map(match => {
        const img = match.images && match.images[0] && match.images[0].photo_reference
          ? `${API_BASE}/api/photo?photo_reference=${match.images[0].photo_reference}&maxwidth=800`
          : (match.images && match.images[0] && match.images[0].url) || '';
        return `
          <div class="match-card">
            <div class="match-card-image" style="background-image:url('${img}')"></div>
            <div class="match-card-content">
              <h3>${match.name || 'Restaurant'}</h3>
              <div class="match-card-rating">‚òÖ ${match.rating || '‚Äî'} (${match.user_ratings_total || 0})</div>
              <p>${match.vicinity || match.formatted_address || ''}</p>
            </div>
          </div>
        `;
      }).join('');
    }

    function randomPickMatch() {
      const list = document.getElementById('matches-list');
      if (!list) return;
      const cards = list.querySelectorAll('.match-card');
      if (!cards.length) return alert('No matches to pick from');
      const pick = cards[Math.floor(Math.random() * cards.length)];
      cards.forEach(c => c.classList.remove('selected'));
      pick.classList.add('selected');
    }

    async function retrySwiping() {
      try {
        const res = await fetch(`${API_BASE}/api/swipe/retry`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode: swipeData.roomCode })
        });
        if (!res.ok) throw new Error('Retry failed ' + res.status);
        // After retry, fetch more restaurants and append to keep flow smooth
        const res2 = await fetch(`${API_BASE}/api/swipe/get-restaurants`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode: swipeData.roomCode, userId: getUserId(), userLocation, userCoordinates })
        });
        if (res2.ok) {
          const data2 = await res2.json();
          const more = data2.restaurants || [];
          // Avoid duplicates by place_id
          const existingIds = new Set((swipeData.currentRestaurants || []).map(r => r.place_id || r.id));
          const uniqueMore = more.filter(r => !existingIds.has(r.place_id || r.id));
          swipeData.currentRestaurants = swipeData.currentRestaurants.concat(uniqueMore);
          prefetchNextImages(3);
        }
      } catch (e) {
        console.error(e); alert('Failed to get more options.');
      }
    }

    function copyRoomCode() {
      const code = document.getElementById('display-room-code').textContent;
      navigator.clipboard.writeText(code).then(() => alert('Copied room code'));
    }

    // Prefetch upcoming images for smooth UX
    function prefetchNextImages(count = 3) {
      const start = swipeData.currentIndex + 1;
      const end = Math.min(start + count, swipeData.currentRestaurants.length);
      for (let i = start; i < end; i++) {
        const r = swipeData.currentRestaurants[i];
        if (!r) continue;
        const src = r.images && r.images[0] && r.images[0].photo_reference
          ? `${API_BASE}/api/photo?photo_reference=${r.images[0].photo_reference}&maxwidth=800`
          : (r.images && r.images[0] && r.images[0].url) || '';
        if (src) {
          const img = new Image();
          img.src = src;
        }
      }
    }

    // If nearing the end, proactively fetch more
    function maybeFetchMoreSoon() {
      const remaining = swipeData.currentRestaurants.length - swipeData.currentIndex - 1;
      if (remaining <= 2) {
        retrySwiping();
      }
    }
  </script>
</body>
</html>

