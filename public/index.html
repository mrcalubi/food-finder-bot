<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>idk what to do</title>
  <link rel="stylesheet" href="style.css"/>
</head>
<body>
  <div class="container">
    <h1>In a bit of a pickle?</h1>
    <p class="subtitle">Ask me anything about food!</p>
    
    <div class="input-box">
      <input id="input" placeholder="e.g. nearby cafe with cheap but good food" onkeypress="handleKeyPress(event)"/>
      <button onclick="getRecommendations()" class="search-button">
        <span class="button-text">Search</span>
        <span class="button-icon">üîç</span>
      </button>
    </div>
    
    <div class="location-box">
      <span id="location-status" class="location-status">üìç Getting your location...</span>
    </div>
    
    <div class="quick-actions">
      <button id="super-nearby-toggle" onclick="toggleFilter('super-nearby')" class="quick-btn super-nearby off">
        <span class="btn-icon">üö∂‚Äç‚ôÇÔ∏è</span>
        <span class="btn-text">Super Nearby</span>
        <span class="btn-subtitle">300m</span>
      </button>
      <button onclick="quickSearch('surprise-me')" class="quick-btn surprise-me">
        <span class="btn-icon">üòà</span>
        <span class="btn-text">Surprise Me</span>
        <span class="btn-subtitle">Random 4.5+</span>
      </button>
      <button id="imma-walk-toggle" onclick="toggleFilter('imma-walk')" class="quick-btn imma-walk off">
        <span class="btn-icon">üö∂‚Äç‚ôÄÔ∏è</span>
        <span class="btn-text">Imma Walk</span>
        <span class="btn-subtitle">500m</span>
      </button>
      <button id="price-toggle" onclick="togglePriceMode()" class="quick-btn price-toggle off">
        <span class="btn-icon">üí∞</span>
        <span class="btn-text">Any Price</span>
        <span class="btn-subtitle">No filter</span>
      </button>
    </div>
    
    <div class="group-voting" id="group-voting" style="display: none;">
      <div class="voting-header">
        <h3>üéâ Group Voting</h3>
        <button onclick="closeGroupVoting()" class="close-btn">√ó</button>
      </div>
      <div class="voting-content">
        <div class="group-size">
          <label>How many people in your group?</label>
          <input type="number" id="group-size" min="2" max="20" value="4">
        </div>
        <div class="voting-options" id="voting-options">
          <!-- Voting options will be populated here -->
        </div>
        <div class="voting-actions">
          <button onclick="startVoting()" class="start-voting-btn">Start Voting</button>
          <button onclick="revealResults()" class="reveal-btn" style="display: none;">Reveal Results</button>
        </div>
      </div>
    </div>
    
    <div class="group-vote-trigger">
      <button onclick="openGroupVoting()" class="group-vote-btn">
        <span class="btn-icon">üó≥Ô∏è</span>
        <span class="btn-text">Group Vote</span>
      </button>
    </div>
    
    <div id="loading-screen" class="loading-screen hidden">
      <div class="cooking-animation">
        <div class="chef-hat">üë®‚Äçüç≥</div>
        <div class="cooking-text" id="cooking-text">Cooking up a fire suggestion for you...</div>
        <div class="loading-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    </div>
    
    <div id="intent-box"></div>
    <div id="output"></div>
  </div>

  <script>
    let userLocation = null;
    let currentRecommendations = [];
    let userCoordinates = null;
    let userId = null;
    let priceMode = 'off'; // 'off', 'broke', 'ballin'
    let activeFilters = {
      'super-nearby': false,
      'imma-walk': false
    };
    let groupVotingData = {
      isActive: false,
      groupSize: 4,
      votes: {},
      options: []
    };

    // Generate or retrieve user ID
    function getUserId() {
      if (!userId) {
        userId = localStorage.getItem('foodFinderUserId');
        if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('foodFinderUserId', userId);
        }
      }
      return userId;
    }

    // Track user interactions for personalization
    async function trackInteraction(interaction) {
      try {
        const response = await fetch('/interaction', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userId: getUserId(),
            ...interaction
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Interaction tracked:', data);
        }
      } catch (error) {
        console.error('‚ùå Failed to track interaction:', error);
      }
    }

    // Track restaurant selection
    function trackRestaurantSelection(restaurant, query, userIntent) {
      trackInteraction({
        query,
        selectedRestaurant: restaurant,
        userIntent
      });
    }

    // Track restaurant rejection
    function trackRestaurantRejection(restaurant, query, userIntent) {
      trackInteraction({
        query,
        rejectedRestaurants: [restaurant],
        userIntent
      });
    }

    // Get personalized suggestions
    async function getPersonalizedSuggestions(query = '') {
      try {
        const response = await fetch(`/suggestions/${getUserId()}?query=${encodeURIComponent(query)}`);
        if (response.ok) {
          const data = await response.json();
          return data.suggestions || [];
        }
      } catch (error) {
        console.error('‚ùå Failed to get personalized suggestions:', error);
      }
      return [];
    }

    // Like a restaurant
    function likeRestaurant(name, location, price, rating) {
      const restaurant = { name, location, price, rating };
      const query = document.getElementById('input').value;
      
      // Track the interaction
      trackRestaurantSelection(restaurant, query, {
        search_term: query,
        mood: 'casual',
        price_range: 'moderate'
      });
      
      // Show feedback
      showFeedback('‚ù§Ô∏è Thanks! We\'ll remember you like this type of place!');
    }

    // Dislike a restaurant
    function dislikeRestaurant(name, location, price, rating) {
      const restaurant = { name, location, price, rating };
      const query = document.getElementById('input').value;
      
      // Track the interaction
      trackRestaurantRejection(restaurant, query, {
        search_term: query,
        mood: 'casual',
        price_range: 'moderate'
      });
      
      // Show feedback
      showFeedback('üëé Got it! We\'ll avoid similar places in the future.');
    }

    // Show feedback message
    function showFeedback(message) {
      const feedback = document.createElement('div');
      feedback.className = 'feedback-message';
      feedback.textContent = message;
      feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 1000;
        animation: slideInRight 0.3s ease-out;
      `;
      
      document.body.appendChild(feedback);
      
      setTimeout(() => {
        feedback.remove();
      }, 3000);
    }

    // Image modal functionality
    function openImageModal(imageUrl, imageAlt, photographer, allImages = null) {
      // Create modal overlay
      const modal = document.createElement('div');
      modal.className = 'image-modal-overlay';
      modal.onclick = closeImageModal;
      
      // Create modal content
      const modalContent = document.createElement('div');
      modalContent.className = 'image-modal-content';
      modalContent.onclick = (e) => e.stopPropagation();
      
      if (allImages) {
        // Show all images in a carousel
        modalContent.innerHTML = `
          <div class="modal-header">
            <h3>All Photos</h3>
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
          </div>
          <div class="modal-carousel">
            <div class="modal-carousel-container">
              ${allImages.map((img, index) => `
                <div class="modal-slide ${index === 0 ? 'active' : ''}">
                  <img src="${img.url}" alt="${img.alt || 'Restaurant photo'}" class="modal-image">
                  <div class="modal-image-credit">Official Photo</div>
                </div>
              `).join('')}
            </div>
            <div class="modal-carousel-controls">
              <button class="modal-prev" onclick="changeModalSlide(-1)">‚Äπ</button>
              <button class="modal-next" onclick="changeModalSlide(1)">‚Ä∫</button>
            </div>
            <div class="modal-indicators">
              ${allImages.map((_, index) => `
                <span class="modal-indicator ${index === 0 ? 'active' : ''}" onclick="goToModalSlide(${index})"></span>
              `).join('')}
            </div>
          </div>
        `;
      } else {
        // Show single image
        modalContent.innerHTML = `
          <div class="modal-header">
            <h3>${imageAlt}</h3>
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
          </div>
          <div class="modal-image-container">
            <img src="${imageUrl}" alt="${imageAlt}" class="modal-image">
            <div class="modal-image-credit">Official Photo</div>
          </div>
        `;
      }
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }

    function closeImageModal() {
      const modal = document.querySelector('.image-modal-overlay');
      if (modal) {
        modal.remove();
        document.body.style.overflow = 'auto';
      }
    }

    function changeModalSlide(direction) {
      const slides = document.querySelectorAll('.modal-slide');
      const indicators = document.querySelectorAll('.modal-indicator');
      const currentActive = document.querySelector('.modal-slide.active');
      const currentIndex = Array.from(slides).indexOf(currentActive);
      
      let newIndex = currentIndex + direction;
      if (newIndex >= slides.length) newIndex = 0;
      if (newIndex < 0) newIndex = slides.length - 1;
      
      goToModalSlide(newIndex);
    }

    function goToModalSlide(index) {
      const slides = document.querySelectorAll('.modal-slide');
      const indicators = document.querySelectorAll('.modal-indicator');
      
      slides.forEach(slide => slide.classList.remove('active'));
      indicators.forEach(indicator => indicator.classList.remove('active'));
      
      if (slides[index]) slides[index].classList.add('active');
      if (indicators[index]) indicators[index].classList.add('active');
    }

    
    // Comprehensive dietary restrictions database
    const dietaryDatabase = {
      'halal': { emoji: 'üïå', name: 'Halal' },
      'vegetarian': { emoji: 'ü•¨', name: 'Vegetarian' },
      'vegan': { emoji: 'üå±', name: 'Vegan' },
      'gluten-free': { emoji: 'üåæ', name: 'Gluten-Free' },
      'keto': { emoji: 'ü•ë', name: 'Keto' },
      'paleo': { emoji: 'ü•©', name: 'Paleo' },
      'dairy-free': { emoji: 'ü•õ', name: 'Dairy-Free' },
      'nut-free': { emoji: 'ü•ú', name: 'Nut-Free' },
      'kosher': { emoji: '‚ú°Ô∏è', name: 'Kosher' },
      'no-eggs': { emoji: 'ü•ö', name: 'No Eggs' },
      'low-sodium': { emoji: 'üßÇ', name: 'Low Sodium' },
      'sugar-free': { emoji: 'üçØ', name: 'Sugar-Free' },
      'raw-food': { emoji: 'ü•ï', name: 'Raw Food' },
      'pescatarian': { emoji: 'üêü', name: 'Pescatarian' },
      'lactose-free': { emoji: 'ü•õ', name: 'Lactose-Free' }
    };

    // Create price range display with money bags
    function createPriceBags(priceRange) {
      const priceLevels = {
        'budget': 1,
        'moderate': 2,
        'expensive': 4,
        'luxury': 5,
        'any': 2
      };
      
      const level = priceLevels[priceRange] || 2;
      let bags = '';
      
      for (let i = 1; i <= 5; i++) {
        const opacity = i <= level ? '1' : '0.3';
        bags += `<span class="money-bag" style="opacity: ${opacity}">üí∞</span>`;
      }
      
      return bags;
    }

    // Create dietary restrictions display
    function createDietaryDisplay(restrictions) {
      if (!restrictions || restrictions.length === 0) {
        return '<span class="no-restrictions">‚ùå None specified</span>';
      }
      
      return restrictions.map(restriction => {
        const info = dietaryDatabase[restriction.toLowerCase()];
        if (info) {
          return `<span class="dietary-tag">${info.emoji} ${info.name}</span>`;
        }
        return `<span class="dietary-tag">ü•ó ${restriction}</span>`;
      }).join(' ');
    }

    // Pick for me functionality
    function pickForMe() {
      if (currentRecommendations.length === 0) {
        alert('No recommendations available to pick from!');
        return;
      }
      
      const output = document.getElementById('output');
      const cards = output.querySelectorAll('.card');
      
      // Remove previous selection highlight
      cards.forEach(card => card.classList.remove('selected'));
      
      // Pick random recommendation
      const randomIndex = Math.floor(Math.random() * currentRecommendations.length);
      const selectedCard = cards[randomIndex];
      
      // Add selection animation
      selectedCard.classList.add('selected');
      
      // Scroll to selected card
      selectedCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Show pick animation
      showPickAnimation(selectedCard);
    }

    // Show pick animation
    function showPickAnimation(card) {
      const animation = document.createElement('div');
      animation.className = 'pick-animation';
      animation.innerHTML = 'üéØ Picked for you!';
      
      card.appendChild(animation);
      
      setTimeout(() => {
        animation.remove();
      }, 2000);
    }

    let loadingMessages = [
      "Cooking up a fire suggestion for you...",
      "Sifting through the best spots...",
      "Adding a pinch of local flavor...",
      "Whisking up perfect recommendations...",
      "Saut√©ing the finest options...",
      "Baking fresh suggestions just for you...",
      "Grilling the top picks...",
      "Simmering the perfect match...",
      "Plating your ideal recommendations...",
      "Adding the secret sauce to your search..."
    ];

    // Show loading screen with random message
    function showLoading() {
      const loadingScreen = document.getElementById('loading-screen');
      const cookingText = document.getElementById('cooking-text');
      
      // Pick a random loading message
      const randomMessage = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
      cookingText.textContent = randomMessage;
      
      loadingScreen.classList.remove('hidden');
      loadingScreen.classList.add('fade-in');
    }

    // Hide loading screen
    function hideLoading() {
      const loadingScreen = document.getElementById('loading-screen');
      loadingScreen.classList.add('hidden');
      loadingScreen.classList.remove('fade-in');
    }

    // Update location status display
    function updateLocationStatus(message, isError = false) {
      const locationStatus = document.getElementById('location-status');
      locationStatus.textContent = message;
      locationStatus.style.color = isError ? '#d32f2f' : '#2e7d32';
    }

    // Multi-step location detection with multiple fallbacks
    async function getCurrentLocation() {
      console.log('üîç Starting multi-step location detection...');
      
      // Step 1: Try GPS with high accuracy
      try {
        const gpsLocation = await getLocationFromGPS();
        if (gpsLocation) {
          console.log('‚úÖ GPS location successful:', gpsLocation);
          return gpsLocation;
        }
      } catch (error) {
        console.log('‚ùå GPS failed:', error.message);
      }
      
      // Step 2: Try GPS with lower accuracy (faster)
      try {
        const quickGpsLocation = await getLocationFromGPS(false);
        if (quickGpsLocation) {
          console.log('‚úÖ Quick GPS location successful:', quickGpsLocation);
          return quickGpsLocation;
        }
      } catch (error) {
        console.log('‚ùå Quick GPS failed:', error.message);
      }
      
      // Step 3: Try cached location (if available)
      try {
        const cachedLocation = await getCachedLocation();
        if (cachedLocation) {
          console.log('‚úÖ Cached location successful:', cachedLocation);
          return cachedLocation;
        }
      } catch (error) {
        console.log('‚ùå Cached location failed:', error.message);
      }
      
      // Step 4: Try IP-based location detection
      try {
        const ipLocation = await getLocationFromIP();
        if (ipLocation) {
          console.log('‚úÖ IP-based location successful:', ipLocation);
          return ipLocation;
        }
      } catch (error) {
        console.log('‚ùå IP-based location failed:', error.message);
      }
      
      // Step 5: Ultimate fallback - show fallback UI
      console.log('‚ùå All location methods failed - showing fallbacks');
      throw new Error('All location detection methods failed');
    }

    // Step 1: GPS-based location detection
    async function getLocationFromGPS(highAccuracy = true) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }

        const options = {
          enableHighAccuracy: highAccuracy,
          timeout: highAccuracy ? 15000 : 5000, // Longer timeout for high accuracy
          maximumAge: highAccuracy ? 300000 : 60000 // 5min vs 1min cache
        };

        navigator.geolocation.getCurrentPosition(
          async (position) => {
            const { latitude, longitude } = position.coords;
            userCoordinates = { latitude, longitude };
            
            try {
              // Try Google Geocoding API first
              const response = await fetch(`/api/geocode?lat=${latitude}&lng=${longitude}`);
              const data = await response.json();
              
              if (data.results && data.results.length > 0 && data.status === 'OK') {
                const result = data.results[0];
                const locationName = extractLocationName(result);
                
                // Cache successful location
                cacheLocation(locationName, latitude, longitude);
                
                userLocation = locationName;
                updateLocationStatus(`‚úÖ GPS: ${locationName}`);
                resolve(locationName);
              } else {
                // Use coordinates as fallback
                const coordLocation = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                userLocation = coordLocation;
                updateLocationStatus(`‚úÖ GPS: ${coordLocation}`);
                resolve(coordLocation);
              }
            } catch (error) {
              console.error('Geocoding failed, using coordinates:', error);
              const coordLocation = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
              userLocation = coordLocation;
              updateLocationStatus(`‚úÖ GPS: ${coordLocation}`);
              resolve(coordLocation);
            }
          },
          (error) => {
            let errorMessage = 'GPS location failed';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMessage = 'Location permission denied';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMessage = 'Location unavailable';
                break;
              case error.TIMEOUT:
                errorMessage = 'GPS timeout';
                break;
            }
            reject(new Error(errorMessage));
          },
          options
        );
      });
    }

    // Step 2: Cached location detection
    async function getCachedLocation() {
      try {
        const cached = localStorage.getItem('foodFinder_location');
        const cachedTime = localStorage.getItem('foodFinder_location_time');
        
        if (cached && cachedTime) {
          const age = Date.now() - parseInt(cachedTime);
          const maxAge = 24 * 60 * 60 * 1000; // 24 hours
          
          if (age < maxAge) {
            userLocation = cached;
            updateLocationStatus(`‚úÖ Cached: ${cached}`);
            return cached;
          }
        }
        return null;
      } catch (error) {
        console.error('Cache access failed:', error);
        return null;
      }
    }

    // Step 3: IP-based location detection
    async function getLocationFromIP() {
      try {
        // Try multiple IP geolocation services for redundancy
        const services = [
          'https://ipapi.co/json/',
          'https://ipinfo.io/json',
          'https://api.ipgeolocation.io/ipgeo?apiKey=free'
        ];
        
        for (const service of services) {
          try {
            const response = await fetch(service, { timeout: 5000 });
            const data = await response.json();
            
            let location = null;
            console.log(`IP service ${service} returned:`, data);
            
            if (service.includes('ipapi.co')) {
              const city = data.city || 'Unknown City';
              const region = data.region || 'Unknown Region';
              const country = data.country_name || data.country || 'Unknown Country';
              location = `${city}, ${region}, ${country}`;
            } else if (service.includes('ipinfo.io')) {
              const city = data.city || 'Unknown City';
              const region = data.region || 'Unknown Region';
              const country = data.country || 'Unknown Country';
              location = `${city}, ${region}, ${country}`;
            } else if (service.includes('ipgeolocation.io')) {
              const city = data.city || 'Unknown City';
              const state = data.state_prov || 'Unknown State';
              const country = data.country_name || 'Unknown Country';
              location = `${city}, ${state}, ${country}`;
            }
            
            // Check if we got a valid location (not all "Unknown" or null values)
            if (location && 
                !location.includes('null') && 
                !location.includes('undefined') &&
                location !== 'Unknown City, Unknown Region, Unknown Country' &&
                location !== 'Current Location') {
              userLocation = location;
              updateLocationStatus(`‚úÖ IP: ${location}`);
              cacheLocation(location);
              return location;
            } else {
              console.log(`IP service ${service} returned invalid location: ${location}`);
            }
          } catch (error) {
            console.log(`IP service ${service} failed:`, error.message);
            continue;
          }
        }
        
        // If all IP services failed, return null to trigger fallbacks
        console.log('All IP services failed - returning null to trigger fallbacks');
        return null;
      } catch (error) {
        console.error('IP location detection failed:', error);
        return null;
      }
    }

    // Helper functions
    function extractLocationName(result) {
      const components = result.address_components;
      
      let city = components.find(c => c.types.includes('locality')) || 
                components.find(c => c.types.includes('administrative_area_level_2'));
      let state = components.find(c => c.types.includes('administrative_area_level_1'));
      let country = components.find(c => c.types.includes('country'));
      
      if (city && state && country) {
        return `${city.long_name}, ${state.long_name}, ${country.long_name}`;
      } else if (city && country) {
        return `${city.long_name}, ${country.long_name}`;
      } else if (state && country) {
        return `${state.long_name}, ${country.long_name}`;
      } else {
        return result.formatted_address || 'Current Location';
      }
    }

    function cacheLocation(locationName, latitude = null, longitude = null) {
      try {
        localStorage.setItem('foodFinder_location', locationName);
        localStorage.setItem('foodFinder_location_time', Date.now().toString());
        if (latitude && longitude) {
          localStorage.setItem('foodFinder_coordinates', JSON.stringify({ latitude, longitude }));
        }
      } catch (error) {
        console.error('Failed to cache location:', error);
      }
    }

    async function getRecommendations(searchType = null) {
      const query = document.getElementById("input").value.trim();
      
      // Validate input
      if (!query) {
        alert('Please enter what you\'re looking for!');
        return;
      }
      
      // Show loading screen
      showLoading();
      
      // Clear previous results
      document.getElementById("output").innerHTML = "";
      document.getElementById("intent-box").innerHTML = "";

      // Check for network connectivity
      if (!navigator.onLine) {
        console.log('No internet connection detected');
        await showFallbackRecommendations('no_internet');
        return;
      }

      // Get user location if not already available
      if (!userLocation) {
        console.log("üìç No user location detected, trying to get location...");
        try {
          await getCurrentLocation();
          console.log("‚úÖ Location obtained:", userLocation);
        } catch (error) {
          console.log('‚ùå All location methods failed:', error);
          await showFallbackRecommendations('no_location');
          return;
        }
      } else {
        console.log("üìç Using existing location:", userLocation);
      }

      try {
        // Determine search type based on active filters
        let finalSearchType = searchType;
        if (!finalSearchType) {
          if (activeFilters['super-nearby'] && activeFilters['imma-walk']) {
            finalSearchType = 'imma-walk'; // Prefer closer option
          } else if (activeFilters['super-nearby']) {
            finalSearchType = 'super-nearby';
          } else if (activeFilters['imma-walk']) {
            finalSearchType = 'imma-walk';
          }
        }

        const requestBody = { 
          query,
          userLocation: userLocation,
          searchType: finalSearchType,
          priceMode: priceMode === 'off' ? null : priceMode,
          userCoordinates: {
            ...userCoordinates,
            userId: getUserId()
          }
        };

        console.log("üöÄ Sending request to /recommend with body:", requestBody);
        
        const res = await fetch("/recommend", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody)
        });

        console.log("üì° Response status:", res.status, res.statusText);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: "Unknown error" }));
          console.error("‚ùå Server error response:", errorData);
          
          // Handle specific error cases
          if (res.status === 400) {
            document.getElementById("output").innerHTML = `
              <div class="error-message">
                <h3>Invalid Request</h3>
                <p>${errorData.error || 'Please check your input and try again.'}</p>
                ${errorData.suggestions ? `
                  <div style="margin-top: 1rem;">
                    <p><strong>Try these instead:</strong></p>
                    <ul style="text-align: left; display: inline-block;">
                      ${errorData.suggestions.map(s => `<li>${s}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
              </div>
            `;
            return;
          }
          
          throw new Error(`Server returned ${res.status}: ${errorData.error || 'Unknown error'}`);
        }

        const data = await res.json();
        console.log("‚úÖ Response received:", data);

        // Handle needs clarification
        if (data.intent && data.intent.needs_clarification) {
          document.getElementById("output").innerHTML = `
            <div class="clarification-container">
              <div class="clarification-header">
                <div class="clarification-emoji">ü§î</div>
                <h2>I need a bit more info!</h2>
                <p>Help me understand what you're looking for:</p>
              </div>
              <div class="clarification-options">
                ${data.intent.suggested_alternatives.map(option => `
                  <button class="clarification-btn" onclick="selectClarification('${option}')">
                    ${option}
                  </button>
                `).join('')}
              </div>
            </div>
          `;
          return;
        }

        // Show parsed intent with enhanced display
        if (data.intent) {
          const priceRange = data.intent.price_range || 'any';
          const dietaryRestrictions = data.intent.dietary_restrictions || [];
          const location = data.intent.location || 'Not specified';
          const mood = data.intent.mood || 'casual';
          const confidence = data.intent.confidence || 0.8;
          
          // Create price range display with money bags
          const priceBags = createPriceBags(priceRange);
          
          // Create dietary restrictions display
          const dietaryDisplay = createDietaryDisplay(dietaryRestrictions);

          // Create mood display
          const moodEmoji = {
            'casual': 'üòä',
            'romantic': 'üíï',
            'celebration': 'üéâ',
            'comfort': 'ü§ó',
            'adventure': 'üåü'
          };

          document.getElementById("intent-box").innerHTML = `
            <div class="intent">
              <div class="intent-row">
                <span class="intent-label">üìç Location:</span>
                <span class="intent-value location-value">${location}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">üí∞ Price Range:</span>
                <span class="intent-value price-bags">${priceBags}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">ü•ó Dietary:</span>
                <span class="intent-value dietary-display">${dietaryDisplay}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">${moodEmoji[mood] || 'üòä'} Mood:</span>
                <span class="intent-value">${mood.charAt(0).toUpperCase() + mood.slice(1)}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">üéØ Confidence:</span>
                <span class="intent-value">${Math.round(confidence * 100)}%</span>
              </div>
              ${data.metadata.sources_used ? `
                <div class="intent-row">
                  <span class="intent-label">üìä Data Sources:</span>
                  <span class="intent-value">${data.metadata.sources_used.map(source => source.charAt(0).toUpperCase() + source.slice(1)).join(', ')}</span>
                </div>
                <div class="intent-row">
                  <span class="intent-label">üîç Results Found:</span>
                  <span class="intent-value">${data.metadata.source_counts ? Object.entries(data.metadata.source_counts).map(([source, count]) => `${source.charAt(0).toUpperCase() + source.slice(1)}: ${count}`).join(', ') : 'N/A'}</span>
                </div>
              ` : ''}
            </div>
          `;
        }
        
        // Handle no results
        if (!data.recommendations || data.recommendations.length === 0) {
          console.log("‚ùå No recommendations found");
          document.getElementById("output").innerHTML = `
            <div class="no-results-container">
              <div class="no-results-header">
                <div class="no-results-emoji">üîç</div>
                <h2>No results found</h2>
                <p>Try adjusting your search or filters</p>
              </div>
              <div class="no-results-suggestions">
                <button class="suggestion-btn" onclick="broadenSearch()">
                  <span class="suggestion-icon">üîç</span>
                  <span class="suggestion-text">Broaden Search</span>
                </button>
                <button class="suggestion-btn" onclick="clearFilters()">
                  <span class="suggestion-icon">üîÑ</span>
                  <span class="suggestion-text">Clear Filters</span>
                </button>
              </div>
            </div>
          `;
          return;
        }
        
        console.log("‚úÖ Recommendations found, proceeding to render");

        // Store recommendations for pick for me functionality
        currentRecommendations = data.recommendations;
        
        try {
          renderResults(data.recommendations);
          console.log("Successfully rendered results");
        } catch (renderError) {
          console.error("Error in renderResults:", renderError);
          throw renderError;
        }

      } catch (err) {
        console.error("Error in getRecommendations:", err);
        
        // Check if it's a network error or API failure
        if (!navigator.onLine || err.message.includes('fetch') || err.message.includes('Failed to fetch')) {
          await showFallbackRecommendations('network_error');
        } else {
          document.getElementById("output").innerHTML = `
            <div class="error-message">
              <h3>Oops! Something went wrong</h3>
              <p>Please try again or check your internet connection.</p>
              <p style="font-size: 0.8rem; color: #666;">Error: ${err.message}</p>
              <button onclick="getRecommendations()" class="retry-btn">Try Again</button>
            </div>
          `;
        }
      } finally {
        // Hide loading screen
        hideLoading();
      }
    }

    function renderResults(results) {
      if (!Array.isArray(results)) results = [results];

      // Add pick for me button
      const pickButton = `
        <div class="pick-for-me-container">
          <button onclick="pickForMe()" class="pick-for-me-btn">
            <span class="dice-emoji">üé≤</span>
            <span class="pick-text">Pick for Me!</span>
          </button>
        </div>
      `;

      const resultsHTML = results.map(r => `
        <div class="card">
          <div class="card-header">
          <h3>${r.name || "Unknown"}</h3>
            <div class="rating-badge">
              ${r.rating ? `<span class="stars">${'‚≠ê'.repeat(Math.floor(r.rating))}</span> ${r.rating}/5` : ""}
              ${r.user_ratings_total ? `<span class="review-count">(${r.user_ratings_total} reviews)</span>` : ""}
            </div>
          </div>
          ${r.images && r.images.length > 0 ? `
            <div class="restaurant-images-gallery">
              <div class="gallery-container">
                ${r.images.slice(0, 4).map((img, index) => `
                  <div class="gallery-item ${index === 0 ? 'featured' : ''}" onclick="openImageModal('${img.url}', '${img.alt || r.name}', '')">
                    <img src="${img.url}" alt="${img.alt || r.name}" class="gallery-image" loading="lazy" 
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="image-placeholder" style="display: none; align-items: center; justify-content: center; background: #f5f5f5; color: #666; font-size: 14px; text-align: center; padding: 20px;">
                      <div>
                        <div style="font-size: 24px; margin-bottom: 8px;">üì∑</div>
                        <div>${img.alt || r.name}</div>
                        <div style="font-size: 12px; margin-top: 4px;">Image unavailable</div>
                      </div>
                    </div>
                    <div class="image-credit">Official Photo</div>
                  </div>
                `).join('')}
                ${r.images.length > 4 ? `<div class="more-photos" onclick="openImageModal('', '', '', ${JSON.stringify(r.images).replace(/"/g, '&quot;')})">+${r.images.length - 4} more</div>` : ''}
              </div>
            </div>
          ` : ''}
          <p>üìç ${r.location || "N/A"} ${r.distance_formatted ? `(${r.distance_formatted} away)` : ''}</p>
          <p>üí∞ ${r.price || "N/A"}</p>
          
          ${r.reason ? `
            <details class="reason">
              <summary>üí° Why this place?</summary>
              <p>${r.reason}</p>
            </details>
          ` : ""}
          
          ${r.dietary_match ? `
            <details class="reason">
              <summary>ü•ó Dietary Options</summary>
              <p>${r.dietary_match}</p>
            </details>
          ` : ""}
          
          ${r.occasion_fit ? `
            <details class="reason">
              <summary>üéâ Perfect For</summary>
              <p>${r.occasion_fit}</p>
            </details>
          ` : ""}
          
          ${r.unique_selling_point ? `
            <details class="reason">
              <summary>‚ú® What Makes It Special</summary>
              <p>${r.unique_selling_point}</p>
            </details>
          ` : ""}
          
          ${r.low_rating_reason ? `
            <details class="reason low-rating">
              <summary>‚ö†Ô∏è Why We Still Recommend This</summary>
              <p>${r.low_rating_reason}</p>
            </details>
          ` : ""}
          
          <div class="restaurant-actions">
            <a href="https://www.google.com/maps/search/?api=1&query=${encodeURIComponent((r.name || "") + " " + (r.location || ""))}" 
               target="_blank" class="action-btn primary">üìç Open in Maps</a>
            <button class="action-btn like" onclick="likeRestaurant('${r.name}', '${r.location}', '${r.price}', '${r.rating}')">
              ‚ù§Ô∏è Like
            </button>
            <button class="action-btn dislike" onclick="dislikeRestaurant('${r.name}', '${r.location}', '${r.price}', '${r.rating}')">
              üëé Dislike
            </button>
          </div>
        </div>
      `).join("");

      document.getElementById("output").innerHTML = pickButton + resultsHTML;
    }

    // Toggle filter function (no animation, just toggle state)
    function toggleFilter(type) {
      const button = document.getElementById(`${type}-toggle`);
      const isActive = activeFilters[type];
      
      // Toggle the state
      activeFilters[type] = !isActive;
      
      // Update button appearance
      if (activeFilters[type]) {
        button.classList.remove('off');
        button.classList.add('active');
      } else {
        button.classList.remove('active');
        button.classList.add('off');
      }
      
      console.log(`Filter ${type} toggled:`, activeFilters[type]);
      
      // If it's a distance filter and we have a current query, search again
      if ((type === 'super-nearby' || type === 'imma-walk') && currentQuery) {
        getRecommendations(currentQuery);
      }
    }

    // Quick search functions (only for surprise-me)
    async function quickSearch(type) {
      if (type !== 'surprise-me') return; // Only surprise-me should trigger search
      
      if (!userLocation) {
        alert('Location is still being detected. Please wait a moment and try again.');
        return;
      }

      // Set the input value
      document.getElementById('input').value = 'restaurant near me';
      
      // Show loading with custom message
      showLoading();
      const cookingText = document.getElementById('cooking-text');
      cookingText.textContent = 'Finding a random surprise for you...';

      // Make the search request with search type
      await getRecommendations(type);
    }

    // Price toggle functionality (3 states: off, broke, ballin)
    function togglePriceMode() {
      const toggle = document.getElementById('price-toggle');
      const icon = toggle.querySelector('.btn-icon');
      const text = toggle.querySelector('.btn-text');
      const subtitle = toggle.querySelector('.btn-subtitle');
      
      // Cycle through states: off -> broke -> ballin -> off
      if (priceMode === 'off') {
        priceMode = 'broke';
        icon.textContent = 'üí∞';
        text.textContent = 'Broke';
        subtitle.textContent = '1 money bag';
        toggle.className = 'quick-btn price-toggle broke';
      } else if (priceMode === 'broke') {
        priceMode = 'ballin';
        icon.textContent = 'üíé';
        text.textContent = 'Ballin';
        subtitle.textContent = '5 money bags';
        toggle.className = 'quick-btn price-toggle ballin';
      } else {
        priceMode = 'off';
        icon.textContent = 'üí∞';
        text.textContent = 'Any Price';
        subtitle.textContent = 'No filter';
        toggle.className = 'quick-btn price-toggle off';
      }
    }

    // Group voting functions
    function openGroupVoting() {
      if (currentRecommendations.length === 0) {
        alert('Please get some recommendations first!');
        return;
      }
      
      document.getElementById('group-voting').style.display = 'block';
      groupVotingData.options = currentRecommendations;
      setupVotingOptions();
    }

    function closeGroupVoting() {
      document.getElementById('group-voting').style.display = 'none';
      groupVotingData.isActive = false;
      groupVotingData.votes = {};
    }

    function setupVotingOptions() {
      const optionsContainer = document.getElementById('voting-options');
      optionsContainer.innerHTML = '';
      
      currentRecommendations.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'voting-option';
        optionDiv.innerHTML = `
          <div class="option-info">
            <h4>${option.name}</h4>
            <p>${option.location}</p>
            <div class="option-rating">${'‚≠ê'.repeat(Math.floor(option.rating))} ${option.rating}/5</div>
          </div>
          <div class="vote-count" id="votes-${index}">0 votes</div>
        `;
        optionsContainer.appendChild(optionDiv);
      });
    }

    function startVoting() {
      const groupSize = parseInt(document.getElementById('group-size').value);
      if (groupSize < 2) {
        alert('Group size must be at least 2!');
        return;
      }
      
      groupVotingData.groupSize = groupSize;
      groupVotingData.isActive = true;
      groupVotingData.votes = {};
      
      // Show voting interface
      document.querySelector('.start-voting-btn').style.display = 'none';
      document.querySelector('.reveal-btn').style.display = 'inline-block';
      
      // Add click handlers to options
      const options = document.querySelectorAll('.voting-option');
      options.forEach((option, index) => {
        option.onclick = () => castVote(index);
        option.style.cursor = 'pointer';
      });
      
      alert(`Voting started! Pass the phone around for ${groupSize} people to vote. Each person can vote once.`);
    }

    function castVote(optionIndex) {
      if (!groupVotingData.isActive) return;
      
      const voterId = prompt('Enter your name (anonymous):');
      if (!voterId) return;
      
      if (groupVotingData.votes[voterId]) {
        alert('You already voted!');
        return;
      }
      
      groupVotingData.votes[voterId] = optionIndex;
      
      // Update vote count display
      const voteCount = Object.values(groupVotingData.votes).filter(v => v === optionIndex).length;
      document.getElementById(`votes-${optionIndex}`).textContent = `${voteCount} vote${voteCount !== 1 ? 's' : ''}`;
      
      // Check if all votes are in
      if (Object.keys(groupVotingData.votes).length === groupVotingData.groupSize) {
        alert('All votes are in! Click "Reveal Results" to see the winner!');
      }
    }

    function revealResults() {
      if (!groupVotingData.isActive) return;
      
      // Count votes
      const voteCounts = {};
      Object.values(groupVotingData.votes).forEach(optionIndex => {
        voteCounts[optionIndex] = (voteCounts[optionIndex] || 0) + 1;
      });
      
      // Find winner
      const winnerIndex = Object.keys(voteCounts).reduce((a, b) => 
        voteCounts[a] > voteCounts[b] ? a : b
      );
      
      const winner = currentRecommendations[winnerIndex];
      const winnerVotes = voteCounts[winnerIndex];
      
      // Show results
      alert(`üéâ Winner: ${winner.name}!\n\nVotes: ${winnerVotes}/${groupVotingData.groupSize}\n\nLocation: ${winner.location}\nRating: ${winner.rating}/5`);
      
      // Highlight winner in main results
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => card.classList.remove('group-winner'));
      if (cards[winnerIndex]) {
        cards[winnerIndex].classList.add('group-winner');
        cards[winnerIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      
      groupVotingData.isActive = false;
    }

    // Show conflict UI (contradictory filters)
    function showConflictUI(conflicts, suggestions) {
      const conflictHTML = `
        <div class="conflict-container">
          <div class="conflict-header">
            <div class="conflict-emoji">‚ö†Ô∏è</div>
            <h2 class="conflict-title">Filter Conflict Detected!</h2>
            <p class="conflict-subtitle">Your filters are contradicting each other</p>
          </div>
          
          <div class="conflict-details">
            ${conflicts.map(conflict => `
              <div class="conflict-item">
                <div class="conflict-message">${conflict.message}</div>
                <div class="conflict-filters">
                  Conflicting: ${conflict.conflicting_filters.join(' vs ')}
                </div>
              </div>
            `).join('')}
          </div>
          
          <div class="suggestions-section">
            <h3>üí° Smart Suggestions:</h3>
            <div class="suggestions-list">
              ${suggestions.map(suggestion => `
                <button class="suggestion-btn" onclick="applySuggestion('${suggestion.action}', '${suggestion.new_price_mode || ''}', '${suggestion.new_search_type || ''}', '${suggestion.new_query || ''}')">
                  <span class="suggestion-icon">‚ú®</span>
                  <span class="suggestion-text">${suggestion.message}</span>
                </button>
              `).join('')}
            </div>
          </div>
        </div>
      `;
      
      document.getElementById("output").innerHTML = conflictHTML;
      document.getElementById("intent-box").innerHTML = "";
    }
    
    // Show constraint UI (too restrictive filters)
    function showConstraintUI(constraints, suggestions, metadata) {
      const constraintHTML = `
        <div class="constraint-container">
          <div class="constraint-header">
            <div class="constraint-emoji">üîç</div>
            <h2 class="constraint-title">Filters Too Restrictive!</h2>
            <p class="constraint-subtitle">Found ${metadata.total_found} places, but none match your strict filters</p>
          </div>
          
          <div class="constraint-details">
            <h3>üö´ What's limiting your results:</h3>
            ${constraints.map(constraint => `
              <div class="constraint-item ${constraint.severity}">
                <div class="constraint-message">${constraint.message}</div>
                <div class="constraint-impact">${constraint.impact}</div>
              </div>
            `).join('')}
          </div>
          
          <div class="suggestions-section">
            <h3>üí° Try these adjustments:</h3>
            <div class="suggestions-list">
              ${suggestions.map(suggestion => `
                <button class="suggestion-btn" onclick="applySuggestion('${suggestion.action}', '${suggestion.new_price_mode || ''}', '${suggestion.new_search_type || ''}', '${suggestion.new_query || ''}')">
                  <span class="suggestion-icon">üéØ</span>
                  <span class="suggestion-text">${suggestion.message}</span>
                </button>
              `).join('')}
            </div>
          </div>
        </div>
      `;
      
      document.getElementById("output").innerHTML = constraintHTML;
      document.getElementById("intent-box").innerHTML = "";
    }
    
    // Apply suggestion (adjust filters and re-search)
    function applySuggestion(action, newPriceMode, newSearchType, newQuery) {
      console.log("Applying suggestion:", { action, newPriceMode, newSearchType, newQuery });
      
      // Update price mode
      if (newPriceMode && newPriceMode !== '') {
        priceMode = newPriceMode;
        updatePriceToggleUI();
      }
      
      // Update search type (toggle filters)
      if (newSearchType && newSearchType !== '') {
        // Turn off current filters
        activeFilters['super-nearby'] = false;
        activeFilters['imma-walk'] = false;
        updateFilterUI();
        
        // Turn on new filter
        if (newSearchType === 'super-nearby') {
          activeFilters['super-nearby'] = true;
        } else if (newSearchType === 'imma-walk') {
          activeFilters['imma-walk'] = true;
        }
        updateFilterUI();
      } else if (newSearchType === null) {
        // Turn off all distance filters
        activeFilters['super-nearby'] = false;
        activeFilters['imma-walk'] = false;
        updateFilterUI();
      }
      
      // Update query if provided
      if (newQuery && newQuery !== '') {
        document.getElementById('input').value = newQuery;
      }
      
      // Re-search with new settings
      getRecommendations();
    }
    
    // Update price toggle UI
    function updatePriceToggleUI() {
      const toggle = document.getElementById('price-toggle');
      const icon = toggle.querySelector('.btn-icon');
      const text = toggle.querySelector('.btn-text');
      const subtitle = toggle.querySelector('.btn-subtitle');
      
      if (priceMode === 'broke') {
        icon.textContent = 'üí∞';
        text.textContent = 'Broke';
        subtitle.textContent = '1 money bag';
        toggle.className = 'quick-btn price-toggle broke';
      } else if (priceMode === 'ballin') {
        icon.textContent = 'üíé';
        text.textContent = 'Ballin';
        subtitle.textContent = '5 money bags';
        toggle.className = 'quick-btn price-toggle ballin';
      } else {
        icon.textContent = 'üí∞';
        text.textContent = 'Any Price';
        subtitle.textContent = 'No filter';
        toggle.className = 'quick-btn price-toggle off';
      }
    }
    
    // Update filter UI
    function updateFilterUI() {
      // Update super-nearby
      const superNearbyBtn = document.getElementById('super-nearby-toggle');
      if (activeFilters['super-nearby']) {
        superNearbyBtn.classList.remove('off');
        superNearbyBtn.classList.add('active');
      } else {
        superNearbyBtn.classList.remove('active');
        superNearbyBtn.classList.add('off');
      }
      
      // Update imma-walk
      const immaWalkBtn = document.getElementById('imma-walk-toggle');
      if (activeFilters['imma-walk']) {
        immaWalkBtn.classList.remove('off');
        immaWalkBtn.classList.add('active');
      } else {
        immaWalkBtn.classList.remove('active');
        immaWalkBtn.classList.add('off');
      }
    }

    // Show fallback recommendations with special UI
    async function showFallbackRecommendations(reason) {
      hideLoading();
      
      try {
        const response = await fetch('/api/fallback');
        const data = await response.json();
        
        // Show special fallback UI
        const fallbackHTML = `
          <div class="fallback-container">
            <div class="fallback-header">
              <div class="fallback-emoji">üò±</div>
              <h2 class="fallback-title">It seems your location cannot be detected!</h2>
              <p class="fallback-subtitle">These are some of Caleb's favorites instead!</p>
            </div>
            <div class="fallback-recommendations">
              ${data.recommendations.map(r => `
                <div class="card fallback-card">
                  <div class="card-header">
                    <h3>${r.name}</h3>
                    <div class="rating-badge">
                      <span class="stars">‚≠ê</span>
                      <span class="rating">${r.rating}</span>
                    </div>
                  </div>
                  <div class="card-body">
                    <p class="location">üìç ${r.location}</p>
                    <p class="price">üí∞ ${r.price}</p>
                    <p class="reason">${r.reason}</p>
                    <div class="fallback-badge">Caleb's Pick</div>
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="fallback-footer">
              <p>üí° Try enabling location services or check your internet connection for better recommendations!</p>
            </div>
          </div>
        `;
        
        document.getElementById("output").innerHTML = fallbackHTML;
        
        // Clear intent box for fallback
        document.getElementById("intent-box").innerHTML = "";
        
      } catch (error) {
        console.error('Fallback failed:', error);
        document.getElementById("output").innerHTML = `
          <div class="error-message">
            <h3>üòî Sorry, we're having technical difficulties</h3>
            <p>Please check your internet connection and try again later.</p>
          </div>
        `;
      }
    }

    // Helper functions for new UI elements
    function selectClarification(option) {
      document.getElementById('input').value = option;
      getRecommendations();
    }
    
    function broadenSearch() {
      // Clear all filters
      activeFilters['super-nearby'] = false;
      activeFilters['imma-walk'] = false;
      priceMode = 'off';
      updateFilterUI();
      updatePriceToggleUI();
      
      // Get current query and make it more general
      const currentQuery = document.getElementById('input').value;
      const broadenedQuery = broadenQuery(currentQuery);
      document.getElementById('input').value = broadenedQuery;
      
      getRecommendations();
    }
    
    function clearFilters() {
      // Clear all filters
      activeFilters['super-nearby'] = false;
      activeFilters['imma-walk'] = false;
      priceMode = 'off';
      updateFilterUI();
      updatePriceToggleUI();
      
      getRecommendations();
    }
    
    function broadenQuery(query) {
      const broadeners = [
        'restaurant near me',
        'good food near me',
        'food near me',
        'restaurant',
        'food'
      ];
      
      // If query is very specific, make it more general
      if (query.length > 20) {
        return broadeners[0];
      }
      
      // If query doesn't contain location words, add them
      if (!query.toLowerCase().includes('near') && !query.toLowerCase().includes('around')) {
        return query + ' near me';
      }
      
      return query;
    }

    // Handle Enter key press
    function handleKeyPress(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        getRecommendations();
      }
    }

    // Auto-get location on page load
    window.addEventListener('load', async () => {
      try {
        await getCurrentLocation();
        console.log('‚úÖ Location detection completed successfully');
      } catch (error) {
        console.error('‚ùå All location methods failed:', error);
        updateLocationStatus('‚ùå Location detection failed - will show fallbacks when needed', true);
      }
    });
  </script>
</body>
</html>

