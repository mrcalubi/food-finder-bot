<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Food Finder</title>
  <link rel="stylesheet" href="style.css"/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Sticky Header -->
  <header class="app-header">
    <div class="header-content">
      <div class="logo">üç¥</div>
      <h1 class="header-title">Find food near me</h1>
      <button class="filter-icon" onclick="openFilterModal()">‚öôÔ∏è</button>
    </div>
  </header>

  <div class="container">
    <!-- Main CTA Section -->
    <section class="hero-section">
      <button onclick="getRecommendations()" class="main-cta">
        <span class="cta-text">Find me something to eat</span>
        <span class="cta-icon">üçΩÔ∏è</span>
      </button>
      <p class="cta-subtitle">or <a href="#" onclick="openFilterModal()" class="filter-link">add more details</a></p>
    </section>

    <!-- Quick Chips -->
    <section class="quick-chips">
      <div class="chips-container">
        <button onclick="quickSearch('cheap')" class="chip">Cheap food</button>
        <button onclick="quickSearch('quick')" class="chip">Quick lunch</button>
        <button onclick="quickSearch('coffee')" class="chip">Coffee</button>
        <button onclick="quickSearch('healthy')" class="chip">Healthy</button>
        <button onclick="quickSearch('spicy')" class="chip">Spicy</button>
        <button onclick="quickSearch('surprise-me')" class="chip random">Random üé≤</button>
      </div>
    </section>

    <!-- Collapsible Search Input -->
    <section class="search-section" id="search-section" style="display: none;">
      <div class="search-input-container">
        <input id="input" placeholder="Search by cuisine, mood, or place name‚Ä¶" onkeypress="handleKeyPress(event)"/>
      <button onclick="getRecommendations()" class="search-button">
        <span class="button-icon">üîç</span>
      </button>
    </div>
    </section>
    
    <!-- Location Status -->
    <div class="location-box">
      <span id="location-status" class="location-status">üìç Getting your location...</span>
    </div>
    
    <!-- Filter Modal -->
    <div class="filter-modal-overlay" id="filter-modal" style="display: none;" onclick="closeFilterModalIfOverlay(event)">
      <div class="filter-modal">
        <div class="filter-header">
          <h3>Filter Options</h3>
          <button onclick="closeFilterModal()" class="close-btn">√ó</button>
        </div>
        
        <div class="filter-tabs">
          <button class="tab-btn active" onclick="switchTab('food')">Food</button>
          <button class="tab-btn" onclick="switchTab('place')">Place</button>
          <button class="tab-btn" onclick="switchTab('people')">People</button>
        </div>
        
        <div class="filter-content">
          <!-- Food Tab -->
          <div class="tab-content active" id="food-tab">
            <div class="filter-group">
              <h4>Cuisine</h4>
              <div class="chip-group">
                <button class="filter-chip" onclick="toggleCuisineFilter('italian')">Italian</button>
                <button class="filter-chip" onclick="toggleCuisineFilter('chinese')">Chinese</button>
                <button class="filter-chip" onclick="toggleCuisineFilter('japanese')">Japanese</button>
                <button class="filter-chip" onclick="toggleCuisineFilter('korean')">Korean</button>
                <button class="filter-chip" onclick="toggleCuisineFilter('thai')">Thai</button>
                <button class="filter-chip" onclick="toggleCuisineFilter('mexican')">Mexican</button>
                <button class="filter-chip" onclick="toggleCuisineFilter('indian')">Indian</button>
                <button class="filter-chip" onclick="toggleCuisineFilter('vietnamese')">Vietnamese</button>
              </div>
            </div>
            
            <div class="filter-group">
              <h4>Dietary</h4>
              <div class="chip-group">
                <button class="filter-chip" onclick="toggleDietaryFilter('vegetarian')">Vegetarian</button>
                <button class="filter-chip" onclick="toggleDietaryFilter('vegan')">Vegan</button>
                <button class="filter-chip" onclick="toggleDietaryFilter('halal')">Halal</button>
                <button class="filter-chip" onclick="toggleDietaryFilter('gluten-free')">Gluten-Free</button>
                <button class="filter-chip" onclick="toggleDietaryFilter('keto')">Keto</button>
              </div>
            </div>
          </div>
          
          <!-- Place Tab -->
          <div class="tab-content" id="place-tab">
            <div class="filter-group">
              <h4>Distance</h4>
              <div class="slider-container">
                <input type="range" id="distance-slider" min="0.3" max="10" step="0.1" value="5" onchange="updateDistanceValue()">
                <span id="distance-value">5 km</span>
              </div>
            </div>
            
            <div class="filter-group">
              <h4>Budget</h4>
              <div class="slider-container">
                <input type="range" id="budget-slider" min="1" max="4" step="1" value="2" onchange="updateBudgetValue()">
                <span id="budget-value">$$ Moderate</span>
              </div>
            </div>
            
            <div class="filter-group">
              <h4>Options</h4>
              <div class="toggle-group">
                <label class="toggle-label">
                  <input type="checkbox" id="open-now-toggle" checked>
                  <span class="toggle-text">Open now only</span>
                </label>
                <label class="toggle-label">
                  <input type="checkbox" id="quick-bite-toggle">
                  <span class="toggle-text">Quick bite / Sit-down</span>
                </label>
              </div>
            </div>
          </div>
          
          <!-- People Tab -->
          <div class="tab-content" id="people-tab">
            <div class="filter-group">
              <h4>Occasion</h4>
              <div class="chip-group">
                <button class="filter-chip" onclick="toggleOccasionFilter('date')">Date Night</button>
                <button class="filter-chip" onclick="toggleOccasionFilter('family')">Family</button>
                <button class="filter-chip" onclick="toggleOccasionFilter('business')">Business</button>
                <button class="filter-chip" onclick="toggleOccasionFilter('celebration')">Celebration</button>
                <button class="filter-chip" onclick="toggleOccasionFilter('casual')">Casual</button>
              </div>
            </div>
            
            <div class="filter-group">
              <h4>Group Size</h4>
              <div class="chip-group">
                <button class="filter-chip" onclick="toggleGroupFilter('solo')">Solo</button>
                <button class="filter-chip" onclick="toggleGroupFilter('couple')">Couple</button>
                <button class="filter-chip" onclick="toggleGroupFilter('small-group')">Small Group</button>
                <button class="filter-chip" onclick="toggleGroupFilter('large-group')">Large Group</button>
              </div>
            </div>
          </div>
        </div>
        
        <div class="filter-footer">
          <button onclick="applyFilters()" class="apply-filters-btn">Show 3 results</button>
        </div>
      </div>
    </div>
    
    <!-- Details Modal -->
    <div class="details-modal-overlay" id="details-modal" style="display: none;">
        <div class="details-modal">
            <!-- Sticky Top Bar -->
            <div class="details-header">
                <button class="details-back-btn" onclick="closeDetailsModal()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
      </button>
                <h2 class="details-title">Restaurant Details</h2>
                <button class="details-save-btn" onclick="toggleSaveRestaurant()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
      </button>
            </div>

            <!-- Photo Carousel -->
            <div class="photo-carousel" id="photo-carousel">
                <div class="carousel-container">
                    <div class="carousel-track" id="carousel-track">
                        <!-- Photos will be dynamically inserted here -->
                    </div>
                </div>
                <div class="carousel-indicators" id="carousel-indicators">
                    <!-- Indicators will be dynamically inserted here -->
                </div>
            </div>

            <!-- Restaurant Info -->
            <div class="restaurant-info">
                <div class="restaurant-header">
                    <h1 class="restaurant-name" id="details-restaurant-name">Restaurant Name</h1>
                    <div class="restaurant-rating" id="details-restaurant-rating">
                        <div class="stars">
                            <span class="star">‚òÖ</span>
                            <span class="star">‚òÖ</span>
                            <span class="star">‚òÖ</span>
                            <span class="star">‚òÖ</span>
                            <span class="star">‚òÖ</span>
                        </div>
                        <span class="review-count">(123 reviews)</span>
                    </div>
                </div>

                <div class="restaurant-tags" id="details-restaurant-tags">
                    <!-- Tags will be dynamically inserted here -->
                </div>

                <div class="restaurant-address" id="details-restaurant-address">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                        <circle cx="12" cy="10" r="3"/>
                    </svg>
                    <span>123 Main Street, City, State</span>
                </div>

                <div class="restaurant-hours" id="details-restaurant-hours">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span>Open until 10:00 PM</span>
                </div>

                <div class="restaurant-description" id="details-restaurant-description">
                    <p>This restaurant offers a unique dining experience with fresh ingredients and exceptional service.</p>
                </div>

                <!-- Map Preview -->
                <div class="map-preview" id="map-preview">
                    <div class="map-placeholder">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                            <circle cx="12" cy="10" r="3"/>
                        </svg>
                        <span>Map Preview</span>
                    </div>
                </div>
            </div>

            <!-- Sticky Bottom Action Bar -->
            <div class="details-actions">
                <button class="action-btn primary" onclick="navigateToRestaurant()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                        <circle cx="12" cy="10" r="3"/>
                    </svg>
                    <span>Navigate</span>
      </button>
                <button class="action-btn secondary" onclick="callRestaurant()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                    </svg>
                    <span>Call</span>
                </button>
                <button class="action-btn secondary" onclick="shareRestaurant()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="18" cy="5" r="3"/>
                        <circle cx="6" cy="12" r="3"/>
                        <circle cx="18" cy="19" r="3"/>
                        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                    </svg>
                    <span>Share</span>
      </button>
            </div>
      </div>
    </div>
    
    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scroll-indicator">
      <span>More results below</span>
      <span class="arrow">‚Üì</span>
    </div>
    
    <!-- Modern Group Voting Modal -->
    <div class="group-voting-overlay" id="group-voting" style="display: none;" onclick="closeGroupVotingIfOverlay(event)">
      <div class="group-voting-modal">
        <div class="voting-header">
          <h3>üó≥Ô∏è Group Voting</h3>
          <button onclick="closeGroupVoting()" class="close-btn">√ó</button>
        </div>
        
        <!-- Step 1: Group Size -->
        <div class="voting-step" id="voting-step-1">
          <div class="voting-content">
            <div class="group-size-selector">
              <label>How many people are voting?</label>
              <div class="number-input-container">
                <button onclick="decreaseGroupSize()" class="number-btn">‚àí</button>
                <input type="number" id="group-size" min="2" max="20" value="4" readonly>
                <button onclick="increaseGroupSize()" class="number-btn">+</button>
              </div>
            </div>
            <button onclick="startVoting()" class="modern-btn primary">Start Voting</button>
          </div>
        </div>
        
        <!-- Step 2: Voting -->
        <div class="voting-step" id="voting-step-2" style="display: none;">
          <div class="voting-progress">
            <div class="progress-text">
              <span id="votes-count">0</span> / <span id="votes-total">4</span> votes
            </div>
            <div class="progress-bar">
              <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
          </div>
          <div class="voting-options" id="voting-options">
            <!-- Voting options will be populated here -->
          </div>
          <button onclick="revealResults()" class="modern-btn secondary reveal-btn" id="reveal-btn" style="display: none;">
            üéâ Reveal Winner
          </button>
        </div>
        
        <!-- Step 3: Results -->
        <div class="voting-step" id="voting-step-3" style="display: none;">
          <div class="winner-announcement" id="winner-announcement">
            <!-- Winner will be shown here -->
          </div>
        </div>
      </div>
    </div>
    
    <div class="group-vote-trigger" id="group-vote-trigger" style="display: none;">
      <button onclick="openGroupVoting()" class="group-vote-btn">
        <span class="btn-icon">üó≥Ô∏è</span>
        <span class="btn-text">Group Vote</span>
      </button>
    </div>
    
    <div id="loading-screen" class="loading-screen hidden">
      <div class="cooking-animation">
        <div class="chef-hat">üë®‚Äçüç≥</div>
        <div class="cooking-text" id="cooking-text">Cooking up a fire suggestion for you...</div>
        <div class="loading-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    </div>
    
    <!-- Results Header -->
    <div class="results-header" id="results-header" style="display: none;">
      <button onclick="goBack()" class="back-btn">‚Üê</button>
      <h2 class="results-title">Top picks right now</h2>
      <button onclick="refreshResults()" class="refresh-btn-small">
        <span class="refresh-icon">üîÑ</span>
        <span class="refresh-text">More options</span>
      </button>
    </div>
    
    <!-- Skeleton Loaders for MVP - show while fetching -->
    <!-- WHY: Fast perceived performance = better UX -->
    <div id="skeleton-loaders" class="skeleton-container hidden">
      <div class="skeleton-card skeleton-hero">
        <div class="skeleton-image"></div>
        <div class="skeleton-content">
          <div class="skeleton-line skeleton-title"></div>
          <div class="skeleton-line skeleton-subtitle"></div>
          <div class="skeleton-line skeleton-text"></div>
        </div>
      </div>
      <div class="skeleton-secondary">
        <div class="skeleton-card skeleton-small">
          <div class="skeleton-image"></div>
          <div class="skeleton-content">
            <div class="skeleton-line skeleton-title"></div>
            <div class="skeleton-line skeleton-subtitle"></div>
          </div>
        </div>
        <div class="skeleton-card skeleton-small">
          <div class="skeleton-image"></div>
          <div class="skeleton-content">
            <div class="skeleton-line skeleton-title"></div>
            <div class="skeleton-line skeleton-subtitle"></div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="intent-box"></div>
    <div id="output"></div>
  </div>

  <script>
    let userLocation = null;
    let currentRecommendations = [];
    let userCoordinates = null;
    let userId = null;
    let priceMode = 'off'; // 'off', 'broke', 'ballin'
    let activeFilters = {
      'super-nearby': false,
      'imma-walk': false
    };
    let groupVotingData = {
      isActive: false,
      groupSize: 4,
      votes: {},
      options: []
    };

    // Generate or retrieve user ID
    function getUserId() {
      if (!userId) {
        userId = localStorage.getItem('foodFinderUserId');
        if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('foodFinderUserId', userId);
        }
      }
      return userId;
    }

    // Track user interactions for personalization
    async function trackInteraction(interaction) {
      try {
        const response = await fetch('/interaction', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userId: getUserId(),
            ...interaction
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Interaction tracked:', data);
        }
      } catch (error) {
        console.error('‚ùå Failed to track interaction:', error);
      }
    }

    // Track restaurant selection
    function trackRestaurantSelection(restaurant, query, userIntent) {
      trackInteraction({
        query,
        selectedRestaurant: restaurant,
        userIntent
      });
    }

    // Track restaurant rejection
    function trackRestaurantRejection(restaurant, query, userIntent) {
      trackInteraction({
        query,
        rejectedRestaurants: [restaurant],
        userIntent
      });
    }

    // Get personalized suggestions
    async function getPersonalizedSuggestions(query = '') {
      try {
        const response = await fetch(`/suggestions/${getUserId()}?query=${encodeURIComponent(query)}`);
        if (response.ok) {
          const data = await response.json();
          return data.suggestions || [];
        }
      } catch (error) {
        console.error('‚ùå Failed to get personalized suggestions:', error);
      }
      return [];
    }

    // Like a restaurant
    function likeRestaurant(name, location, price, rating) {
      const restaurant = { name, location, price, rating };
      const query = document.getElementById('input').value;
      
      // Track the interaction
      trackRestaurantSelection(restaurant, query, {
        search_term: query,
        mood: 'casual',
        price_range: 'moderate'
      });
      
      // Show feedback
      showFeedback('‚ù§Ô∏è Thanks! We\'ll remember you like this type of place!');
    }

    // Dislike a restaurant
    function dislikeRestaurant(name, location, price, rating) {
      const restaurant = { name, location, price, rating };
      const query = document.getElementById('input').value;
      
      // Track the interaction
      trackRestaurantRejection(restaurant, query, {
        search_term: query,
        mood: 'casual',
        price_range: 'moderate'
      });
      
      // Show feedback
      showFeedback('üëé Got it! We\'ll avoid similar places in the future.');
    }

    // Show feedback message
    function showFeedback(message) {
      const feedback = document.createElement('div');
      feedback.className = 'feedback-message';
      feedback.textContent = message;
      feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 1000;
        animation: slideInRight 0.3s ease-out;
      `;
      
      document.body.appendChild(feedback);
      
      setTimeout(() => {
        feedback.remove();
      }, 3000);
    }

    // Image modal functionality
    function openImageModal(imageUrl, imageAlt, photographer, allImages = null) {
      // Create modal overlay
      const modal = document.createElement('div');
      modal.className = 'image-modal-overlay';
      modal.onclick = closeImageModal;
      
      // Create modal content
      const modalContent = document.createElement('div');
      modalContent.className = 'image-modal-content';
      modalContent.onclick = (e) => e.stopPropagation();
      
      if (allImages) {
        // Show all images in a carousel
        modalContent.innerHTML = `
          <div class="modal-header">
            <h3>All Photos</h3>
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
          </div>
          <div class="modal-carousel">
            <div class="modal-carousel-container">
              ${allImages.map((img, index) => `
                <div class="modal-slide ${index === 0 ? 'active' : ''}">
                  <img src="${img.url}" alt="${img.alt || 'Restaurant photo'}" class="modal-image">
                  <div class="modal-image-credit">Official Photo</div>
                </div>
              `).join('')}
            </div>
            <div class="modal-carousel-controls">
              <button class="modal-prev" onclick="changeModalSlide(-1)">‚Äπ</button>
              <button class="modal-next" onclick="changeModalSlide(1)">‚Ä∫</button>
            </div>
            <div class="modal-indicators">
              ${allImages.map((_, index) => `
                <span class="modal-indicator ${index === 0 ? 'active' : ''}" onclick="goToModalSlide(${index})"></span>
              `).join('')}
            </div>
          </div>
        `;
      } else {
        // Show single image
        modalContent.innerHTML = `
          <div class="modal-header">
            <h3>${imageAlt}</h3>
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
          </div>
          <div class="modal-image-container">
            <img src="${imageUrl}" alt="${imageAlt}" class="modal-image">
            <div class="modal-image-credit">Official Photo</div>
          </div>
        `;
      }
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }

    function closeImageModal() {
      const modal = document.querySelector('.image-modal-overlay');
      if (modal) {
        modal.remove();
        document.body.style.overflow = 'auto';
      }
    }

    function changeModalSlide(direction) {
      const slides = document.querySelectorAll('.modal-slide');
      const indicators = document.querySelectorAll('.modal-indicator');
      const currentActive = document.querySelector('.modal-slide.active');
      const currentIndex = Array.from(slides).indexOf(currentActive);
      
      let newIndex = currentIndex + direction;
      if (newIndex >= slides.length) newIndex = 0;
      if (newIndex < 0) newIndex = slides.length - 1;
      
      goToModalSlide(newIndex);
    }

    function goToModalSlide(index) {
      const slides = document.querySelectorAll('.modal-slide');
      const indicators = document.querySelectorAll('.modal-indicator');
      
      slides.forEach(slide => slide.classList.remove('active'));
      indicators.forEach(indicator => indicator.classList.remove('active'));
      
      if (slides[index]) slides[index].classList.add('active');
      if (indicators[index]) indicators[index].classList.add('active');
    }

    
    // Comprehensive dietary restrictions database
    const dietaryDatabase = {
      'halal': { emoji: 'üïå', name: 'Halal' },
      'vegetarian': { emoji: 'ü•¨', name: 'Vegetarian' },
      'vegan': { emoji: 'üå±', name: 'Vegan' },
      'gluten-free': { emoji: 'üåæ', name: 'Gluten-Free' },
      'keto': { emoji: 'ü•ë', name: 'Keto' },
      'paleo': { emoji: 'ü•©', name: 'Paleo' },
      'dairy-free': { emoji: 'ü•õ', name: 'Dairy-Free' },
      'nut-free': { emoji: 'ü•ú', name: 'Nut-Free' },
      'kosher': { emoji: '‚ú°Ô∏è', name: 'Kosher' },
      'no-eggs': { emoji: 'ü•ö', name: 'No Eggs' },
      'low-sodium': { emoji: 'üßÇ', name: 'Low Sodium' },
      'sugar-free': { emoji: 'üçØ', name: 'Sugar-Free' },
      'raw-food': { emoji: 'ü•ï', name: 'Raw Food' },
      'pescatarian': { emoji: 'üêü', name: 'Pescatarian' },
      'lactose-free': { emoji: 'ü•õ', name: 'Lactose-Free' }
    };

    // Create price range display with money bags
    function createPriceBags(priceRange) {
      const priceLevels = {
        'budget': 1,
        'moderate': 2,
        'expensive': 4,
        'luxury': 5,
        'any': 2
      };
      
      const level = priceLevels[priceRange] || 2;
      let bags = '';
      
      for (let i = 1; i <= 5; i++) {
        const opacity = i <= level ? '1' : '0.3';
        bags += `<span class="money-bag" style="opacity: ${opacity}">üí∞</span>`;
      }
      
      return bags;
    }

    // Create dietary restrictions display
    function createDietaryDisplay(restrictions) {
      if (!restrictions || restrictions.length === 0) {
        return '<span class="no-restrictions">‚ùå None specified</span>';
      }
      
      return restrictions.map(restriction => {
        const info = dietaryDatabase[restriction.toLowerCase()];
        if (info) {
          return `<span class="dietary-tag">${info.emoji} ${info.name}</span>`;
        }
        return `<span class="dietary-tag">ü•ó ${restriction}</span>`;
      }).join(' ');
    }

    // Pick for me functionality
    function pickForMe() {
      if (currentRecommendations.length === 0) {
        alert('No recommendations available to pick from!');
        return;
      }
      
      const output = document.getElementById('output');
      const cards = output.querySelectorAll('.card');
      
      // Remove previous selection highlight
      cards.forEach(card => card.classList.remove('selected'));
      
      // Pick random recommendation
      const randomIndex = Math.floor(Math.random() * currentRecommendations.length);
      const selectedCard = cards[randomIndex];
      
      // Add selection animation
      selectedCard.classList.add('selected');
      
      // Scroll to selected card
      selectedCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Show pick animation
      showPickAnimation(selectedCard);
    }

    // Show pick animation
    function showPickAnimation(card) {
      const animation = document.createElement('div');
      animation.className = 'pick-animation';
      animation.innerHTML = 'üéØ Picked for you!';
      
      card.appendChild(animation);
      
      setTimeout(() => {
        animation.remove();
      }, 2000);
    }

    let loadingMessages = [
      "Cooking up a fire suggestion for you...",
      "Sifting through the best spots...",
      "Adding a pinch of local flavor...",
      "Whisking up perfect recommendations...",
      "Saut√©ing the finest options...",
      "Baking fresh suggestions just for you...",
      "Grilling the top picks...",
      "Simmering the perfect match...",
      "Plating your ideal recommendations...",
      "Adding the secret sauce to your search..."
    ];

    // Show loading screen with random message
    function showLoading() {
      const loadingScreen = document.getElementById('loading-screen');
      const cookingText = document.getElementById('cooking-text');
      
      // Pick a random loading message
      const randomMessage = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
      cookingText.textContent = randomMessage;
      
      loadingScreen.classList.remove('hidden');
      loadingScreen.classList.add('fade-in');
    }

    // Hide loading screen
    function hideLoading() {
      const loadingScreen = document.getElementById('loading-screen');
      loadingScreen.classList.add('hidden');
      loadingScreen.classList.remove('fade-in');
    }

    // Update location status display
    function updateLocationStatus(message, isError = false) {
      const locationStatus = document.getElementById('location-status');
      locationStatus.textContent = message;
      locationStatus.style.color = isError ? '#d32f2f' : '#2e7d32';
    }

    // Multi-step location detection with multiple fallbacks
    async function getCurrentLocation() {
      console.log('üîç Starting multi-step location detection...');
      
      // Step 1: Try GPS with high accuracy
      try {
        const gpsLocation = await getLocationFromGPS();
        if (gpsLocation) {
          console.log('‚úÖ GPS location successful:', gpsLocation);
          return gpsLocation;
        }
      } catch (error) {
        console.log('‚ùå GPS failed:', error.message);
      }
      
      // Step 2: Try GPS with lower accuracy (faster)
      try {
        const quickGpsLocation = await getLocationFromGPS(false);
        if (quickGpsLocation) {
          console.log('‚úÖ Quick GPS location successful:', quickGpsLocation);
          return quickGpsLocation;
        }
      } catch (error) {
        console.log('‚ùå Quick GPS failed:', error.message);
      }
      
      // Step 3: Try cached location (if available)
      try {
        const cachedLocation = await getCachedLocation();
        if (cachedLocation) {
          console.log('‚úÖ Cached location successful:', cachedLocation);
          return cachedLocation;
        }
      } catch (error) {
        console.log('‚ùå Cached location failed:', error.message);
      }
      
      // Step 4: Try IP-based location detection
      try {
        const ipLocation = await getLocationFromIP();
        if (ipLocation) {
          console.log('‚úÖ IP-based location successful:', ipLocation);
          return ipLocation;
        }
      } catch (error) {
        console.log('‚ùå IP-based location failed:', error.message);
      }
      
      // Step 5: Ultimate fallback - show fallback UI
      console.log('‚ùå All location methods failed - showing fallbacks');
      throw new Error('All location detection methods failed');
    }

    // Step 1: GPS-based location detection
    async function getLocationFromGPS(highAccuracy = true) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }

        const options = {
          enableHighAccuracy: highAccuracy,
          timeout: highAccuracy ? 15000 : 5000, // Longer timeout for high accuracy
          maximumAge: highAccuracy ? 300000 : 60000 // 5min vs 1min cache
        };

        navigator.geolocation.getCurrentPosition(
          async (position) => {
            const { latitude, longitude } = position.coords;
            userCoordinates = { latitude, longitude };
            
            try {
              // Try Google Geocoding API first
              const response = await fetch(`/api/geocode?lat=${latitude}&lng=${longitude}`);
              const data = await response.json();
              
              if (data.results && data.results.length > 0 && data.status === 'OK') {
                const result = data.results[0];
                const locationName = extractLocationName(result);
                
                // Cache successful location
                cacheLocation(locationName, latitude, longitude);
                
                userLocation = locationName;
                updateLocationStatus(`‚úÖ GPS: ${locationName}`);
                resolve(locationName);
              } else {
                // Use coordinates as fallback
                const coordLocation = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                userLocation = coordLocation;
                updateLocationStatus(`‚úÖ GPS: ${coordLocation}`);
                resolve(coordLocation);
              }
            } catch (error) {
              console.error('Geocoding failed, using coordinates:', error);
              const coordLocation = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
              userLocation = coordLocation;
              updateLocationStatus(`‚úÖ GPS: ${coordLocation}`);
              resolve(coordLocation);
            }
          },
          (error) => {
            let errorMessage = 'GPS location failed';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMessage = 'Location permission denied';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMessage = 'Location unavailable';
                break;
              case error.TIMEOUT:
                errorMessage = 'GPS timeout';
                break;
            }
            reject(new Error(errorMessage));
          },
          options
        );
      });
    }

    // Step 2: Cached location detection
    async function getCachedLocation() {
      try {
        const cached = localStorage.getItem('foodFinder_location');
        const cachedTime = localStorage.getItem('foodFinder_location_time');
        
        if (cached && cachedTime) {
          const age = Date.now() - parseInt(cachedTime);
          const maxAge = 24 * 60 * 60 * 1000; // 24 hours
          
          if (age < maxAge) {
            userLocation = cached;
            updateLocationStatus(`‚úÖ Cached: ${cached}`);
            return cached;
          }
        }
        return null;
      } catch (error) {
        console.error('Cache access failed:', error);
        return null;
      }
    }

    // Step 3: IP-based location detection
    async function getLocationFromIP() {
      try {
        // Try multiple IP geolocation services for redundancy
        const services = [
          'https://ipapi.co/json/',
          'https://ipinfo.io/json',
          'https://api.ipgeolocation.io/ipgeo?apiKey=free'
        ];
        
        for (const service of services) {
          try {
            const response = await fetch(service, { timeout: 5000 });
            const data = await response.json();
            
            let location = null;
            console.log(`IP service ${service} returned:`, data);
            
            if (service.includes('ipapi.co')) {
              const city = data.city || 'Unknown City';
              const region = data.region || 'Unknown Region';
              const country = data.country_name || data.country || 'Unknown Country';
              location = `${city}, ${region}, ${country}`;
            } else if (service.includes('ipinfo.io')) {
              const city = data.city || 'Unknown City';
              const region = data.region || 'Unknown Region';
              const country = data.country || 'Unknown Country';
              location = `${city}, ${region}, ${country}`;
            } else if (service.includes('ipgeolocation.io')) {
              const city = data.city || 'Unknown City';
              const state = data.state_prov || 'Unknown State';
              const country = data.country_name || 'Unknown Country';
              location = `${city}, ${state}, ${country}`;
            }
            
            // Check if we got a valid location (not all "Unknown" or null values)
            if (location && 
                !location.includes('null') && 
                !location.includes('undefined') &&
                location !== 'Unknown City, Unknown Region, Unknown Country' &&
                location !== 'Current Location') {
              userLocation = location;
              updateLocationStatus(`‚úÖ IP: ${location}`);
              cacheLocation(location);
              return location;
            } else {
              console.log(`IP service ${service} returned invalid location: ${location}`);
            }
          } catch (error) {
            console.log(`IP service ${service} failed:`, error.message);
            continue;
          }
        }
        
        // If all IP services failed, return null to trigger fallbacks
        console.log('All IP services failed - returning null to trigger fallbacks');
        return null;
      } catch (error) {
        console.error('IP location detection failed:', error);
        return null;
      }
    }

    // Helper functions
    function extractLocationName(result) {
      const components = result.address_components;
      
      let city = components.find(c => c.types.includes('locality')) || 
                components.find(c => c.types.includes('administrative_area_level_2'));
      let state = components.find(c => c.types.includes('administrative_area_level_1'));
      let country = components.find(c => c.types.includes('country'));
      
      if (city && state && country) {
        return `${city.long_name}, ${state.long_name}, ${country.long_name}`;
      } else if (city && country) {
        return `${city.long_name}, ${country.long_name}`;
      } else if (state && country) {
        return `${state.long_name}, ${country.long_name}`;
      } else {
        return result.formatted_address || 'Current Location';
      }
    }

    function cacheLocation(locationName, latitude = null, longitude = null) {
      try {
        localStorage.setItem('foodFinder_location', locationName);
        localStorage.setItem('foodFinder_location_time', Date.now().toString());
        if (latitude && longitude) {
          localStorage.setItem('foodFinder_coordinates', JSON.stringify({ latitude, longitude }));
        }
      } catch (error) {
        console.error('Failed to cache location:', error);
      }
    }

    let refreshCount = 0;
    async function getRecommendations(searchType = null) {
      const query = document.getElementById("input").value.trim();
      
      // SMART VALIDATION: Skip validation for special search types that don't need user input
      const skipValidation = searchType === 'surprise-me' || 
                             activeFilters['super-nearby'] || 
                             activeFilters['imma-walk'];
      
      // Validate input (unless special search type)
      if (!query && !skipValidation) {
        alert('Please enter what you\'re looking for!');
        return;
      }
      
      // Auto-fill query for special cases
      if (!query && skipValidation) {
        document.getElementById("input").value = 'restaurant near me';
      }
      
      // Show skeleton loaders for fast perceived performance
      // WHY: Skeletons feel faster than generic loading screens
      showSkeletons();
      
      // Clear previous results
      document.getElementById("intent-box").innerHTML = "";

      // Check for network connectivity
      if (!navigator.onLine) {
        console.log('No internet connection detected');
        await showFallbackRecommendations('no_internet');
        return;
      }

      // Get user location if not already available
      if (!userLocation) {
        console.log("üìç No user location detected, trying to get location...");
        try {
          await getCurrentLocation();
          console.log("‚úÖ Location obtained:", userLocation);
        } catch (error) {
          console.log('‚ùå All location methods failed:', error);
          await showFallbackRecommendations('no_location');
          return;
        }
      } else {
        console.log("üìç Using existing location:", userLocation);
      }

      try {
        // Determine search type based on active filters
        let finalSearchType = searchType;
        if (!finalSearchType) {
          if (activeFilters['super-nearby'] && activeFilters['imma-walk']) {
            finalSearchType = 'imma-walk'; // Prefer closer option
          } else if (activeFilters['super-nearby']) {
            finalSearchType = 'super-nearby';
          } else if (activeFilters['imma-walk']) {
            finalSearchType = 'imma-walk';
          }
        }

        const requestBody = { 
          query,
          userLocation: userLocation,
          searchType: finalSearchType,
          priceMode: priceMode === 'off' ? null : priceMode,
          userCoordinates: {
            ...userCoordinates,
            userId: getUserId()
          },
          // Variety controls
          randomSeed: Date.now() ^ Math.floor(Math.random() * 1e9),
          refreshCount: refreshCount || 0,
          avoidPlaceIds: (currentRecommendations || []).map(r => r.place_id).filter(Boolean)
        };

        console.log("üöÄ Sending request to /recommend with body:", requestBody);
        
        const res = await fetch("/recommend", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody)
        });

        console.log("üì° Response status:", res.status, res.statusText);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: "Unknown error" }));
          console.error("‚ùå Server error response:", errorData);
          
          // Handle specific error cases
          if (res.status === 400) {
            document.getElementById("output").innerHTML = `
              <div class="error-message">
                <h3>Invalid Request</h3>
                <p>${errorData.error || 'Please check your input and try again.'}</p>
                ${errorData.suggestions ? `
                  <div style="margin-top: 1rem;">
                    <p><strong>Try these instead:</strong></p>
                    <ul style="text-align: left; display: inline-block;">
                      ${errorData.suggestions.map(s => `<li>${s}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
              </div>
            `;
            return;
          }
          
          throw new Error(`Server returned ${res.status}: ${errorData.error || 'Unknown error'}`);
        }

        const data = await res.json();
        console.log("‚úÖ Response received:", data);

        // Handle needs clarification
        if (data.intent && data.intent.needs_clarification) {
          document.getElementById("output").innerHTML = `
            <div class="clarification-container">
              <div class="clarification-header">
                <div class="clarification-emoji">ü§î</div>
                <h2>I need a bit more info!</h2>
                <p>Help me understand what you're looking for:</p>
              </div>
              <div class="clarification-options">
                ${data.intent.suggested_alternatives.map(option => `
                  <button class="clarification-btn" onclick="selectClarification('${option}')">
                    ${option}
                  </button>
                `).join('')}
              </div>
            </div>
          `;
          return;
        }

        // Show parsed intent with enhanced display
        if (data.intent) {
          const priceRange = data.intent.price_range || 'any';
          const dietaryRestrictions = data.intent.dietary_restrictions || [];
          const location = data.intent.location || 'Not specified';
          const mood = data.intent.mood || 'casual';
          const confidence = data.intent.confidence || 0.8;
          
          // Create price range display with money bags
          const priceBags = createPriceBags(priceRange);
          
          // Create dietary restrictions display
          const dietaryDisplay = createDietaryDisplay(dietaryRestrictions);

          // Create mood display
          const moodEmoji = {
            'casual': 'üòä',
            'romantic': 'üíï',
            'celebration': 'üéâ',
            'comfort': 'ü§ó',
            'adventure': 'üåü'
          };

          document.getElementById("intent-box").innerHTML = `
            <div class="intent">
              <div class="intent-row">
                <span class="intent-label">üìç Location:</span>
                <span class="intent-value location-value">${location}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">üí∞ Price Range:</span>
                <span class="intent-value price-bags">${priceBags}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">ü•ó Dietary:</span>
                <span class="intent-value dietary-display">${dietaryDisplay}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">${moodEmoji[mood] || 'üòä'} Mood:</span>
                <span class="intent-value">${mood.charAt(0).toUpperCase() + mood.slice(1)}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">üéØ Confidence:</span>
                <span class="intent-value">${Math.round(confidence * 100)}%</span>
              </div>
              ${data.metadata.sources_used ? `
                <div class="intent-row">
                  <span class="intent-label">üìä Data Sources:</span>
                  <span class="intent-value">${data.metadata.sources_used.map(source => source.charAt(0).toUpperCase() + source.slice(1)).join(', ')}</span>
                </div>
                <div class="intent-row">
                  <span class="intent-label">üîç Results Found:</span>
                  <span class="intent-value">${data.metadata.source_counts ? Object.entries(data.metadata.source_counts).map(([source, count]) => `${source.charAt(0).toUpperCase() + source.slice(1)}: ${count}`).join(', ') : 'N/A'}</span>
                </div>
              ` : ''}
            </div>
          `;
        }
        
        // Handle no results
        if (!data.recommendations || data.recommendations.length === 0) {
          console.log("‚ùå No recommendations found");
          document.getElementById("output").innerHTML = `
            <div class="no-results-container">
              <div class="no-results-header">
                <div class="no-results-emoji">üîç</div>
                <h2>No results found</h2>
                <p>Try adjusting your search or filters</p>
              </div>
              <div class="no-results-suggestions">
                <button class="suggestion-btn" onclick="broadenSearch()">
                  <span class="suggestion-icon">üîç</span>
                  <span class="suggestion-text">Broaden Search</span>
                </button>
                <button class="suggestion-btn" onclick="clearFilters()">
                  <span class="suggestion-icon">üîÑ</span>
                  <span class="suggestion-text">Clear Filters</span>
                </button>
              </div>
            </div>
          `;
          return;
        }
        
        console.log("‚úÖ Recommendations found, proceeding to render");

        // Store recommendations for pick for me functionality
        currentRecommendations = data.recommendations;
        
        try {
          renderResults(data.recommendations);
          console.log("Successfully rendered results");
        } catch (renderError) {
          console.error("Error in renderResults:", renderError);
          throw renderError;
        }

      } catch (err) {
        console.error("Error in getRecommendations:", err);
        
        // Check if it's a network error or API failure
        if (!navigator.onLine || err.message.includes('fetch') || err.message.includes('Failed to fetch')) {
          await showFallbackRecommendations('network_error');
        } else {
          document.getElementById("output").innerHTML = `
            <div class="error-message">
              <h3>Oops! Something went wrong</h3>
              <p>Please try again or check your internet connection.</p>
              <p style="font-size: 0.8rem; color: #666;">Error: ${err.message}</p>
              <button onclick="getRecommendations()" class="retry-btn">Try Again</button>
            </div>
          `;
        }
      } finally {
        // Hide loading screen
        hideLoading();
      }
    }

    // Show skeleton loaders for fast perceived performance
    function showSkeletons() {
      document.getElementById('skeleton-loaders')?.classList.remove('hidden');
      document.getElementById('output').innerHTML = '';
    }
    
    function hideSkeletons() {
      document.getElementById('skeleton-loaders')?.classList.add('hidden');
    }

    function renderResults(results) {
      hideSkeletons(); // Hide skeletons when real data arrives
      
      if (!Array.isArray(results)) results = [results];

      // MVP: Show only 3 results (1 hero + 2 alternates)
      // WHY: Reduces decision fatigue, faster load, higher quality curation
      const displayResults = results.slice(0, 3);
      
      // Show results header and hide home elements
      document.getElementById('results-header').style.display = 'flex';
      document.querySelector('.hero-section').style.display = 'none';
      document.querySelector('.quick-chips').style.display = 'none';

      const resultsHTML = displayResults.map((r, idx) => {
        const isHero = idx === 0;
        const cardClass = isHero ? 'card-hero' : 'card-alternate';
        const label = idx === 1 ? 'Safe choice' : idx === 2 ? 'New experience' : '';
        
        return `
          <div class="card ${cardClass}" data-place-id="${r.place_id || ''}" onclick="openDetailsModal(${idx})">
            ${label ? `<div class="card-label">${label}</div>` : ''}
            
            <!-- Card Image -->
          ${r.images && r.images.length > 0 ? `
              <div class="card-image-container">
                <img src="${r.images[0].url}" alt="${r.images[0].alt || r.name}" class="card-image" loading="lazy">
                <div class="image-overlay">
                  ${r.is_open_now ? '<span class="status-badge open">Open now</span>' : '<span class="status-badge closed">Closes soon</span>'}
                  ${r.distance_formatted ? `<span class="distance-badge">${r.distance_formatted}</span>` : ''}
                      </div>
                
                <!-- Mini-map thumbnail -->
                <div class="mini-map">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                    <circle cx="12" cy="10" r="3"/>
                  </svg>
              </div>
            </div>
          ` : ''}
            
            <!-- Card Content -->
            <div class="card-content">
              <div class="card-header">
                <h3 class="card-title">${r.name || "Unknown"}</h3>
                <div class="rating-inline">‚≠ê ${r.rating && typeof r.rating === 'number' ? r.rating.toFixed(1) : '4.5'}</div>
              </div>
              
              <!-- Tags Row -->
              <div class="tags-row">
                ${r.why_factors && r.why_factors.length > 0 ? r.why_factors.slice(0, 3).map(factor => `
                  <span class="tag">${factor}</span>
                `).join('') : ''}
              </div>

              <!-- Description -->
              <div class="description-text">
                ${r.description || 'This restaurant offers a unique dining experience with fresh ingredients and exceptional service.'}
              </div>
              
              <!-- Why this pick -->
              <div class="why-pick">
                Why this pick: ${r.reason || 'Great food + close by + highly rated'}
              </div>
              
              <!-- Action Buttons -->
              <div class="card-actions">
                <button class="action-btn primary" onclick="event.stopPropagation(); navigateToRestaurant('${r.name}', '${r.location}')">
                  <span class="btn-icon">üó∫Ô∏è</span>
                  <span class="btn-text">Navigate</span>
                </button>
                <button class="action-btn secondary" onclick="event.stopPropagation(); callRestaurant('${r.name}')">
                  <span class="btn-icon">üìû</span>
                  <span class="btn-text">Call</span>
                </button>
                <button class="action-btn tertiary" onclick="event.stopPropagation(); saveRestaurant('${r.name}', '${r.location}')">
                  <span class="btn-icon">‚ù§Ô∏è</span>
                  <span class="btn-text">Save</span>
            </button>
          </div>
        </div>
        </div>
      `;
      }).join("");

      // Update the output with results
      document.getElementById("output").innerHTML = resultsHTML;
      
      // Add fade-in animation
      setTimeout(() => {
        document.querySelectorAll('.card').forEach((card, index) => {
          card.style.opacity = '0';
          card.style.transform = 'translateY(20px)';
          setTimeout(() => {
            card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            card.style.opacity = '1';
            card.style.transform = 'translateY(0)';
          }, index * 100);
        });
      }, 50);
    }
    
    // "Not into this" button - learns from user rejections and refreshes
    // WHY: Personalization through negative feedback, shows we're listening
    function notIntoThis(placeId, placeName, cardIndex) {
      console.log(`User rejected: ${placeName}`);
      
      // Track rejection for future personalization
      const query = document.getElementById('input').value;
      trackRestaurantRejection({ name: placeName, place_id: placeId }, query, {});
      
      // Visual feedback - fade out the card
      const cards = document.querySelectorAll('.card');
      if (cards[cardIndex]) {
        cards[cardIndex].style.opacity = '0.5';
        cards[cardIndex].style.transition = 'opacity 0.3s ease';
      }
      
      // Show feedback toast
      showFeedback('üëç Got it! Finding better matches...');
      
      // Auto-refresh after short delay for better options
      setTimeout(() => {
        refreshResults();
      }, 800);
    }

    // Refresh results to increase variety and avoid repeats
    async function refreshResults() {
      // Increment refresh counter to gradually broaden search on backend
      refreshCount = (refreshCount || 0) + 1;
      showLoading();
      const cookingText = document.getElementById('cooking-text');
      if (cookingText) cookingText.textContent = 'Refreshing with new variety...';
      await getRecommendations();
    }

    // Toggle filter function (no animation, just toggle state)
    function toggleFilter(type) {
      const button = document.getElementById(`${type}-toggle`);
      const isActive = activeFilters[type];
      
      // EXCLUSIVE TOGGLE: Super Nearby and Imma Walk are mutually exclusive
      if (type === 'super-nearby' && !isActive) {
        // Turn off Imma Walk
        if (activeFilters['imma-walk']) {
          activeFilters['imma-walk'] = false;
          const immaWalkBtn = document.getElementById('imma-walk-toggle');
          immaWalkBtn.classList.remove('active');
          immaWalkBtn.classList.add('off');
        }
      } else if (type === 'imma-walk' && !isActive) {
        // Turn off Super Nearby
        if (activeFilters['super-nearby']) {
          activeFilters['super-nearby'] = false;
          const superNearbyBtn = document.getElementById('super-nearby-toggle');
          superNearbyBtn.classList.remove('active');
          superNearbyBtn.classList.add('off');
        }
      }
      
      // Toggle the state
      activeFilters[type] = !isActive;
      
      // Update button appearance
      if (activeFilters[type]) {
        button.classList.remove('off');
        button.classList.add('active');
      } else {
        button.classList.remove('active');
        button.classList.add('off');
      }
      
      console.log(`Filter ${type} toggled:`, activeFilters[type]);
      
      // AUTO-SEARCH: If distance filter is activated AND we have results or a query, search again
      if ((type === 'super-nearby' || type === 'imma-walk')) {
        const query = document.getElementById('input').value.trim();
        const hasResults = currentRecommendations && currentRecommendations.length > 0;
        
        // If filter is turned ON, auto-search
        if (activeFilters[type] && (query || hasResults)) {
          // Use existing query or default to last search
          const searchQuery = query || 'restaurant near me';
          document.getElementById('input').value = searchQuery;
          getRecommendations();
        }
        // If filter is turned OFF and we have results, refresh
        else if (!activeFilters[type] && hasResults && query) {
          getRecommendations();
        }
      }
    }

    // Quick search functions (only for surprise-me)
    async function quickSearch(type) {
      if (type !== 'surprise-me') return; // Only surprise-me should trigger search
      
      if (!userLocation) {
        alert('Location is still being detected. Please wait a moment and try again.');
        return;
      }

      // If input is empty, default to a broad query; otherwise keep user's term
      const inputEl = document.getElementById('input');
      const currentVal = inputEl.value.trim();
      if (!currentVal) {
        inputEl.value = 'restaurant near me';
      }
      
      // Show loading with custom message
      showLoading();
      const cookingText = document.getElementById('cooking-text');
      cookingText.textContent = 'Finding a random surprise for you...';

      // Make the search request with search type
      await getRecommendations(type);
    }

    // Price toggle functionality (3 states: off, broke, ballin)
    function togglePriceMode() {
      const toggle = document.getElementById('price-toggle');
      const icon = toggle.querySelector('.btn-icon');
      const text = toggle.querySelector('.btn-text');
      const subtitle = toggle.querySelector('.btn-subtitle');
      
      // Cycle through states: off -> broke -> ballin -> off
      if (priceMode === 'off') {
        priceMode = 'broke';
        icon.textContent = 'üí∞';
        text.textContent = 'Broke';
        subtitle.textContent = '1 money bag';
        toggle.className = 'quick-btn price-toggle broke';
      } else if (priceMode === 'broke') {
        priceMode = 'ballin';
        icon.textContent = 'üíé';
        text.textContent = 'Ballin';
        subtitle.textContent = '5 money bags';
        toggle.className = 'quick-btn price-toggle ballin';
      } else {
        priceMode = 'off';
        icon.textContent = 'üí∞';
        text.textContent = 'Any Price';
        subtitle.textContent = 'No filter';
        toggle.className = 'quick-btn price-toggle off';
      }
      
      // AUTO-SEARCH: If we have results, refresh with new price filter
      const query = document.getElementById('input').value.trim();
      const hasResults = currentRecommendations && currentRecommendations.length > 0;
      
      if (hasResults && query) {
        getRecommendations();
      }
    }

    // Group voting functions
    function openGroupVoting() {
      if (currentRecommendations.length === 0) {
        showToast('Please get some recommendations first!', 'warning');
        return;
      }
      
      document.getElementById('group-voting').style.display = 'flex';
      document.getElementById('voting-step-1').style.display = 'block';
      document.getElementById('voting-step-2').style.display = 'none';
      document.getElementById('voting-step-3').style.display = 'none';
      groupVotingData.options = currentRecommendations;
      setupVotingOptions();
    }

    function closeGroupVoting() {
      document.getElementById('group-voting').style.display = 'none';
      groupVotingData.isActive = false;
      groupVotingData.votes = {};
    }
    
    function closeGroupVotingIfOverlay(event) {
      if (event.target.classList.contains('group-voting-overlay')) {
        closeGroupVoting();
      }
    }
    
    function increaseGroupSize() {
      const input = document.getElementById('group-size');
      if (input.value < 20) input.value = parseInt(input.value) + 1;
    }
    
    function decreaseGroupSize() {
      const input = document.getElementById('group-size');
      if (input.value > 2) input.value = parseInt(input.value) - 1;
    }
    
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => toast.classList.add('show'), 10);
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    function setupVotingOptions() {
      const optionsContainer = document.getElementById('voting-options');
      optionsContainer.innerHTML = '';
      
      currentRecommendations.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'voting-option';
        optionDiv.innerHTML = `
          <div class="option-info">
            <h4>${option.name}</h4>
            <p>${option.location}</p>
            <div class="option-rating">${'‚≠ê'.repeat(Math.floor(option.rating))} ${option.rating}/5</div>
          </div>
        `;
        optionsContainer.appendChild(optionDiv);
      });
    }

    function startVoting() {
      const groupSize = parseInt(document.getElementById('group-size').value);
      if (groupSize < 2) {
        showToast('Group size must be at least 2!', 'warning');
        return;
      }
      
      groupVotingData.groupSize = groupSize;
      groupVotingData.isActive = true;
      groupVotingData.votes = {};
      
      // Switch to voting step
      document.getElementById('voting-step-1').style.display = 'none';
      document.getElementById('voting-step-2').style.display = 'block';
      document.getElementById('votes-total').textContent = groupSize;
      document.getElementById('votes-count').textContent = '0';
      
      // Add click handlers to options
      const options = document.querySelectorAll('.voting-option');
      options.forEach((option, index) => {
        option.onclick = () => castVote(index);
        option.style.cursor = 'pointer';
      });
      
      showToast(`Pass the phone around for ${groupSize} people to vote!`, 'info');
    }

    function castVote(optionIndex) {
      if (!groupVotingData.isActive) return;
      
      // Generate anonymous voter ID
      const voterId = `voter_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Check if this device already voted (track by voting count)
      const currentVoteCount = Object.keys(groupVotingData.votes).length;
      if (currentVoteCount >= groupVotingData.groupSize) {
        showToast('All votes have been cast!', 'warning');
        return;
      }
      
      groupVotingData.votes[voterId] = optionIndex;
      
      const votedCount = Object.keys(groupVotingData.votes).length;
      
      // Update progress bar
      document.getElementById('votes-count').textContent = votedCount;
      const percentage = (votedCount / groupVotingData.groupSize) * 100;
      document.getElementById('progress-fill').style.width = percentage + '%';
      
      // Add visual feedback to voted option
      const options = document.querySelectorAll('.voting-option');
      options[optionIndex].classList.add('voted');
      setTimeout(() => options[optionIndex].classList.remove('voted'), 500);
      
      showToast(`Vote recorded! (${votedCount}/${groupVotingData.groupSize})`, 'success');
      
      // Check if all votes are in
      if (votedCount === groupVotingData.groupSize) {
        document.getElementById('reveal-btn').style.display = 'block';
        showToast('All votes are in! Ready to reveal the winner!', 'success');
      }
    }

    function revealResults() {
      if (!groupVotingData.isActive) return;
      
      // Count votes
      const voteCounts = {};
      Object.values(groupVotingData.votes).forEach(optionIndex => {
        voteCounts[optionIndex] = (voteCounts[optionIndex] || 0) + 1;
      });
      
      // Find winner
      const winnerIndex = Object.keys(voteCounts).reduce((a, b) => 
        voteCounts[a] > voteCounts[b] ? a : b
      );
      
      const winner = currentRecommendations[winnerIndex];
      const winnerVotes = voteCounts[winnerIndex];
      
      // Show winner in modal
      document.getElementById('voting-step-2').style.display = 'none';
      document.getElementById('voting-step-3').style.display = 'block';
      
      const winnerHTML = `
        <div class="confetti">üéâ</div>
        <h2 class="winner-title">We have a winner!</h2>
        <div class="winner-card">
          <div class="winner-icon">üèÜ</div>
          <h3>${winner.name}</h3>
          <div class="winner-stats">
            <div class="stat">
              <span class="stat-label">Votes</span>
              <span class="stat-value">${winnerVotes}/${groupVotingData.groupSize}</span>
            </div>
            <div class="stat">
              <span class="stat-label">Rating</span>
              <span class="stat-value">‚≠ê ${winner.rating}/5</span>
            </div>
          </div>
          <p class="winner-location">üìç ${winner.location}</p>
          <p class="winner-price">üí∞ ${winner.price || 'N/A'}</p>
        </div>
        <button onclick="closeGroupVoting()" class="modern-btn primary">View on Map</button>
      `;
      
      document.getElementById('winner-announcement').innerHTML = winnerHTML;
      
      // Highlight winner in main results
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => card.classList.remove('group-winner'));
      if (cards[winnerIndex]) {
        cards[winnerIndex].classList.add('group-winner');
      }
      
      groupVotingData.isActive = false;
      
      // Auto-close and scroll to winner after delay
      setTimeout(() => {
        closeGroupVoting();
        const cards = document.querySelectorAll('.card');
        if (cards[winnerIndex]) {
          cards[winnerIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 5000);
    }

    // Show conflict UI (contradictory filters)
    function showConflictUI(conflicts, suggestions) {
      const conflictHTML = `
        <div class="conflict-container">
          <div class="conflict-header">
            <div class="conflict-emoji">‚ö†Ô∏è</div>
            <h2 class="conflict-title">Filter Conflict Detected!</h2>
            <p class="conflict-subtitle">Your filters are contradicting each other</p>
          </div>
          
          <div class="conflict-details">
            ${conflicts.map(conflict => `
              <div class="conflict-item">
                <div class="conflict-message">${conflict.message}</div>
                <div class="conflict-filters">
                  Conflicting: ${conflict.conflicting_filters.join(' vs ')}
                </div>
              </div>
            `).join('')}
          </div>
          
          <div class="suggestions-section">
            <h3>üí° Smart Suggestions:</h3>
            <div class="suggestions-list">
              ${suggestions.map(suggestion => `
                <button class="suggestion-btn" onclick="applySuggestion('${suggestion.action}', '${suggestion.new_price_mode || ''}', '${suggestion.new_search_type || ''}', '${suggestion.new_query || ''}')">
                  <span class="suggestion-icon">‚ú®</span>
                  <span class="suggestion-text">${suggestion.message}</span>
                </button>
              `).join('')}
            </div>
          </div>
        </div>
      `;
      
      document.getElementById("output").innerHTML = conflictHTML;
      document.getElementById("intent-box").innerHTML = "";
    }
    
    // Show constraint UI (too restrictive filters)
    function showConstraintUI(constraints, suggestions, metadata) {
      const constraintHTML = `
        <div class="constraint-container">
          <div class="constraint-header">
            <div class="constraint-emoji">üîç</div>
            <h2 class="constraint-title">Filters Too Restrictive!</h2>
            <p class="constraint-subtitle">Found ${metadata.total_found} places, but none match your strict filters</p>
          </div>
          
          <div class="constraint-details">
            <h3>üö´ What's limiting your results:</h3>
            ${constraints.map(constraint => `
              <div class="constraint-item ${constraint.severity}">
                <div class="constraint-message">${constraint.message}</div>
                <div class="constraint-impact">${constraint.impact}</div>
              </div>
            `).join('')}
          </div>
          
          <div class="suggestions-section">
            <h3>üí° Try these adjustments:</h3>
            <div class="suggestions-list">
              ${suggestions.map(suggestion => `
                <button class="suggestion-btn" onclick="applySuggestion('${suggestion.action}', '${suggestion.new_price_mode || ''}', '${suggestion.new_search_type || ''}', '${suggestion.new_query || ''}')">
                  <span class="suggestion-icon">üéØ</span>
                  <span class="suggestion-text">${suggestion.message}</span>
                </button>
              `).join('')}
            </div>
          </div>
        </div>
      `;
      
      document.getElementById("output").innerHTML = constraintHTML;
      document.getElementById("intent-box").innerHTML = "";
    }
    
    // Apply suggestion (adjust filters and re-search)
    function applySuggestion(action, newPriceMode, newSearchType, newQuery) {
      console.log("Applying suggestion:", { action, newPriceMode, newSearchType, newQuery });
      
      // Update price mode
      if (newPriceMode && newPriceMode !== '') {
        priceMode = newPriceMode;
        updatePriceToggleUI();
      }
      
      // Update search type (toggle filters)
      if (newSearchType && newSearchType !== '') {
        // Turn off current filters
        activeFilters['super-nearby'] = false;
        activeFilters['imma-walk'] = false;
        updateFilterUI();
        
        // Turn on new filter
        if (newSearchType === 'super-nearby') {
          activeFilters['super-nearby'] = true;
        } else if (newSearchType === 'imma-walk') {
          activeFilters['imma-walk'] = true;
        }
        updateFilterUI();
      } else if (newSearchType === null) {
        // Turn off all distance filters
        activeFilters['super-nearby'] = false;
        activeFilters['imma-walk'] = false;
        updateFilterUI();
      }
      
      // Update query if provided
      if (newQuery && newQuery !== '') {
        document.getElementById('input').value = newQuery;
      }
      
      // Re-search with new settings
      getRecommendations();
    }
    
    // Update price toggle UI
    function updatePriceToggleUI() {
      const toggle = document.getElementById('price-toggle');
      const icon = toggle.querySelector('.btn-icon');
      const text = toggle.querySelector('.btn-text');
      const subtitle = toggle.querySelector('.btn-subtitle');
      
      if (priceMode === 'broke') {
        icon.textContent = 'üí∞';
        text.textContent = 'Broke';
        subtitle.textContent = '1 money bag';
        toggle.className = 'quick-btn price-toggle broke';
      } else if (priceMode === 'ballin') {
        icon.textContent = 'üíé';
        text.textContent = 'Ballin';
        subtitle.textContent = '5 money bags';
        toggle.className = 'quick-btn price-toggle ballin';
      } else {
        icon.textContent = 'üí∞';
        text.textContent = 'Any Price';
        subtitle.textContent = 'No filter';
        toggle.className = 'quick-btn price-toggle off';
      }
    }
    
    // Update filter UI
    function updateFilterUI() {
      // Update super-nearby
      const superNearbyBtn = document.getElementById('super-nearby-toggle');
      if (activeFilters['super-nearby']) {
        superNearbyBtn.classList.remove('off');
        superNearbyBtn.classList.add('active');
      } else {
        superNearbyBtn.classList.remove('active');
        superNearbyBtn.classList.add('off');
      }
      
      // Update imma-walk
      const immaWalkBtn = document.getElementById('imma-walk-toggle');
      if (activeFilters['imma-walk']) {
        immaWalkBtn.classList.remove('off');
        immaWalkBtn.classList.add('active');
      } else {
        immaWalkBtn.classList.remove('active');
        immaWalkBtn.classList.add('off');
      }
    }

    // Show fallback recommendations with special UI
    async function showFallbackRecommendations(reason) {
      hideLoading();
      
      try {
        const response = await fetch('/api/fallback');
        const data = await response.json();
        
        // Show special fallback UI
        const fallbackHTML = `
          <div class="fallback-container">
            <div class="fallback-header">
              <div class="fallback-emoji">üò±</div>
              <h2 class="fallback-title">It seems your location cannot be detected!</h2>
              <p class="fallback-subtitle">These are some of Caleb's favorites instead!</p>
            </div>
            <div class="fallback-recommendations">
              ${data.recommendations.map(r => `
                <div class="card fallback-card">
                  <div class="card-header">
                    <h3>${r.name}</h3>
                    <div class="rating-badge">
                      <span class="stars">‚≠ê</span>
                      <span class="rating">${r.rating}</span>
                    </div>
                  </div>
                  <div class="card-body">
                    <p class="location">üìç ${r.location}</p>
                    <p class="price">üí∞ ${r.price}</p>
                    <p class="reason">${r.reason}</p>
                    <div class="fallback-badge">Caleb's Pick</div>
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="fallback-footer">
              <p>üí° Try enabling location services or check your internet connection for better recommendations!</p>
            </div>
          </div>
        `;
        
        document.getElementById("output").innerHTML = fallbackHTML;
        
        // Clear intent box for fallback
        document.getElementById("intent-box").innerHTML = "";
        
      } catch (error) {
        console.error('Fallback failed:', error);
        document.getElementById("output").innerHTML = `
          <div class="error-message">
            <h3>üòî Sorry, we're having technical difficulties</h3>
            <p>Please check your internet connection and try again later.</p>
          </div>
        `;
      }
    }

    // Helper functions for new UI elements
    function selectClarification(option) {
      document.getElementById('input').value = option;
      getRecommendations();
    }
    
    function broadenSearch() {
      // Clear all filters
      activeFilters['super-nearby'] = false;
      activeFilters['imma-walk'] = false;
      priceMode = 'off';
      updateFilterUI();
      updatePriceToggleUI();
      
      // Get current query and make it more general
      const currentQuery = document.getElementById('input').value;
      const broadenedQuery = broadenQuery(currentQuery);
      document.getElementById('input').value = broadenedQuery;
      
      getRecommendations();
    }
    
    function clearFilters() {
      // Clear all filters
      activeFilters['super-nearby'] = false;
      activeFilters['imma-walk'] = false;
      priceMode = 'off';
      updateFilterUI();
      updatePriceToggleUI();
      
      getRecommendations();
    }
    
    function broadenQuery(query) {
      const broadeners = [
        'restaurant near me',
        'good food near me',
        'food near me',
        'restaurant',
        'food'
      ];
      
      // If query is very specific, make it more general
      if (query.length > 20) {
        return broadeners[0];
      }
      
      // If query doesn't contain location words, add them
      if (!query.toLowerCase().includes('near') && !query.toLowerCase().includes('around')) {
        return query + ' near me';
      }
      
      return query;
    }

    // Handle Enter key press
    function handleKeyPress(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        getRecommendations();
      }
    }

    // Filter Modal Functions
    function openFilterModal() {
      document.getElementById('filter-modal').style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    function closeFilterModal() {
      document.getElementById('filter-modal').style.display = 'none';
      document.body.style.overflow = 'auto';
    }

    function closeFilterModalIfOverlay(event) {
      if (event.target.classList.contains('filter-modal-overlay')) {
        closeFilterModal();
      }
    }

    function switchTab(tabName) {
      // Remove active class from all tabs and content
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      
      // Add active class to selected tab and content
      event.target.classList.add('active');
      document.getElementById(tabName + '-tab').classList.add('active');
    }

    function toggleCuisineFilter(cuisine) {
      event.target.classList.toggle('active');
    }

    function toggleDietaryFilter(dietary) {
      event.target.classList.toggle('active');
    }

    function toggleOccasionFilter(occasion) {
      event.target.classList.toggle('active');
    }

    function toggleGroupFilter(group) {
      event.target.classList.toggle('active');
    }

    function updateDistanceValue() {
      const slider = document.getElementById('distance-slider');
      const value = document.getElementById('distance-value');
      const distance = parseFloat(slider.value);
      value.textContent = distance < 1 ? `${Math.round(distance * 1000)}m` : `${distance} km`;
    }

    function updateBudgetValue() {
      const slider = document.getElementById('budget-slider');
      const value = document.getElementById('budget-value');
      const budgetLevels = {
        1: '$ Budget',
        2: '$$ Moderate', 
        3: '$$$ Expensive',
        4: '$$$$ Luxury'
      };
      value.textContent = budgetLevels[slider.value];
    }

    function applyFilters() {
      // Collect filter values
      const filters = {
        cuisine: Array.from(document.querySelectorAll('#food-tab .filter-chip.active')).map(chip => chip.textContent.toLowerCase()),
        dietary: Array.from(document.querySelectorAll('#food-tab .filter-chip.active')).map(chip => chip.textContent.toLowerCase()),
        distance: parseFloat(document.getElementById('distance-slider').value),
        budget: parseInt(document.getElementById('budget-slider').value),
        openNow: document.getElementById('open-now-toggle').checked,
        quickBite: document.getElementById('quick-bite-toggle').checked,
        occasion: Array.from(document.querySelectorAll('#people-tab .filter-chip.active')).map(chip => chip.textContent.toLowerCase()),
        groupSize: Array.from(document.querySelectorAll('#people-tab .filter-chip.active')).map(chip => chip.textContent.toLowerCase())
      };
      
      // Build search query from filters
      let query = '';
      if (filters.cuisine.length > 0) {
        query += filters.cuisine.join(' ') + ' ';
      }
      if (filters.dietary.length > 0) {
        query += filters.dietary.join(' ') + ' ';
      }
      if (filters.occasion.length > 0) {
        query += filters.occasion.join(' ') + ' ';
      }
      
      // Set the input value and search
      document.getElementById('input').value = query.trim() || 'restaurant near me';
      closeFilterModal();
      getRecommendations();
    }

    function goBack() {
      // Hide results and show home screen
      document.getElementById('results-header').style.display = 'none';
      document.getElementById('output').innerHTML = '';
      document.getElementById('intent-box').innerHTML = '';
      
      // Show home elements
      document.querySelector('.hero-section').style.display = 'block';
      document.querySelector('.quick-chips').style.display = 'block';
    }

    function quickSearch(type) {
      const queries = {
        'cheap': 'cheap food near me',
        'quick': 'quick lunch near me',
        'coffee': 'coffee near me',
        'healthy': 'healthy food near me',
        'spicy': 'spicy food near me',
        'surprise-me': 'surprise me'
      };
      
      document.getElementById('input').value = queries[type] || 'restaurant near me';
      getRecommendations();
    }

    // Helper functions for new UI
    function navigateToRestaurant(name, location) {
      const query = encodeURIComponent(`${name} ${location}`);
      window.open(`https://www.google.com/maps/search/?api=1&query=${query}`, '_blank');
    }

    function callRestaurant(name) {
      // This would typically open a phone dialer or show contact info
      alert(`Calling ${name}...`);
    }

    function saveRestaurant(name, location) {
      // This would save to favorites
      showFeedback(`‚ù§Ô∏è Saved ${name} to favorites!`);
    }

    function openDetailsModal(index) {
      const restaurant = currentResults[index];
      if (!restaurant) return;
      
      // Populate restaurant details
      document.getElementById('details-restaurant-name').textContent = restaurant.name;
      
      // Update rating
      const rating = restaurant.rating || 4.5;
      const reviewCount = restaurant.reviewCount || Math.floor(Math.random() * 500) + 50;
      const starsContainer = document.querySelector('#details-restaurant-rating .stars');
      const reviewCountSpan = document.querySelector('#details-restaurant-rating .review-count');
      
      starsContainer.innerHTML = '';
      for (let i = 1; i <= 5; i++) {
        const star = document.createElement('span');
        star.className = 'star';
        star.textContent = i <= Math.floor(rating) ? '‚òÖ' : '‚òÜ';
        star.style.color = i <= Math.floor(rating) ? '#ffd700' : '#e0e0e0';
        starsContainer.appendChild(star);
      }
      reviewCountSpan.textContent = `(${reviewCount} reviews)`;
      
      // Update tags
      const tagsContainer = document.getElementById('details-restaurant-tags');
      tagsContainer.innerHTML = '';
      const tags = restaurant.tags || ['Popular', 'Good Value', 'Quick Service'];
      tags.forEach(tag => {
        const tagElement = document.createElement('span');
        tagElement.className = 'tag';
        tagElement.textContent = tag;
        tagsContainer.appendChild(tagElement);
      });
      
      // Update address
      document.getElementById('details-restaurant-address').querySelector('span').textContent = restaurant.location || '123 Main Street, City, State';
      
      // Update hours
      const hoursText = restaurant.hours || 'Open until 10:00 PM';
      document.getElementById('details-restaurant-hours').querySelector('span').textContent = hoursText;
      
      // Update description
      const description = restaurant.description || 'This restaurant offers a unique dining experience with fresh ingredients and exceptional service.';
      document.getElementById('details-restaurant-description').querySelector('p').textContent = description;
      
      // Populate photo carousel
      populatePhotoCarousel(restaurant);
      
      // Show modal
      document.getElementById('details-modal').style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    function closeDetailsModal() {
      document.getElementById('details-modal').style.display = 'none';
      document.body.style.overflow = 'auto';
    }

    function populatePhotoCarousel(restaurant) {
      const carouselTrack = document.getElementById('carousel-track');
      const indicators = document.getElementById('carousel-indicators');
      
      // Clear existing content
      carouselTrack.innerHTML = '';
      indicators.innerHTML = '';
      
      // Generate sample photos (in real app, these would come from restaurant data)
      const photos = [
        restaurant.image || 'https://images.unsplash.com/photo-1517248135467-4c7edcad34c4?w=800&h=600&fit=crop',
        'https://images.unsplash.com/photo-1555396273-367ea4eb4db5?w=800&h=600&fit=crop',
        'https://images.unsplash.com/photo-1571091718767-18b5b1457add?w=800&h=600&fit=crop',
        'https://images.unsplash.com/photo-1565299624946-b28f40a0ca4b?w=800&h=600&fit=crop'
      ];
      
      photos.forEach((photo, index) => {
        // Create photo slide
        const slide = document.createElement('div');
        slide.className = 'carousel-slide';
        slide.style.backgroundImage = `url(${photo})`;
        carouselTrack.appendChild(slide);
        
        // Create indicator
        const indicator = document.createElement('button');
        indicator.className = 'carousel-indicator';
        if (index === 0) indicator.classList.add('active');
        indicator.onclick = () => goToSlide(index);
        indicators.appendChild(indicator);
      });
      
      // Set up carousel
      currentSlide = 0;
      updateCarousel();
    }

    function goToSlide(index) {
      currentSlide = index;
      updateCarousel();
    }

    function updateCarousel() {
      const track = document.getElementById('carousel-track');
      const indicators = document.querySelectorAll('.carousel-indicator');
      
      track.style.transform = `translateX(-${currentSlide * 100}%)`;
      
      indicators.forEach((indicator, index) => {
        indicator.classList.toggle('active', index === currentSlide);
      });
    }

    function toggleSaveRestaurant() {
      const saveBtn = document.querySelector('.details-save-btn');
      const isSaved = saveBtn.classList.contains('saved');
      
      if (isSaved) {
        saveBtn.classList.remove('saved');
        showFeedback('Removed from favorites');
      } else {
        saveBtn.classList.add('saved');
        showFeedback('‚ù§Ô∏è Saved to favorites!');
      }
    }

    function shareRestaurant() {
      const restaurantName = document.getElementById('details-restaurant-name').textContent;
      const restaurantAddress = document.getElementById('details-restaurant-address').querySelector('span').textContent;
      
      if (navigator.share) {
        navigator.share({
          title: `Check out ${restaurantName}`,
          text: `I found this great restaurant: ${restaurantName} at ${restaurantAddress}`,
          url: window.location.href
        });
      } else {
        // Fallback: copy to clipboard
        const shareText = `Check out ${restaurantName} at ${restaurantAddress}`;
        navigator.clipboard.writeText(shareText).then(() => {
          showFeedback('Restaurant info copied to clipboard!');
        });
      }
    }

    // Carousel variables
    let currentSlide = 0;
    let carouselInterval;

    // Initialize carousel auto-play
    function startCarousel() {
      carouselInterval = setInterval(() => {
        const slides = document.querySelectorAll('.carousel-slide');
        if (slides.length > 1) {
          currentSlide = (currentSlide + 1) % slides.length;
          updateCarousel();
        }
      }, 4000);
    }

    function stopCarousel() {
      if (carouselInterval) {
        clearInterval(carouselInterval);
      }
    }

    // Add touch/swipe support for carousel
    let startX = 0;
    let endX = 0;

    document.addEventListener('touchstart', (e) => {
      if (e.target.closest('.photo-carousel')) {
        startX = e.touches[0].clientX;
      }
    });

    document.addEventListener('touchend', (e) => {
      if (e.target.closest('.photo-carousel')) {
        endX = e.changedTouches[0].clientX;
        handleSwipe();
      }
    });

    function handleSwipe() {
      const threshold = 50;
      const diff = startX - endX;
      
      if (Math.abs(diff) > threshold) {
        const slides = document.querySelectorAll('.carousel-slide');
        if (slides.length > 1) {
          if (diff > 0) {
            // Swipe left - next slide
            currentSlide = (currentSlide + 1) % slides.length;
          } else {
            // Swipe right - previous slide
            currentSlide = (currentSlide - 1 + slides.length) % slides.length;
          }
          updateCarousel();
        }
      }
    }

    // Auto-get location on page load
    window.addEventListener('load', async () => {
      try {
        await getCurrentLocation();
        console.log('‚úÖ Location detection completed successfully');
      } catch (error) {
        console.error('‚ùå All location methods failed:', error);
        updateLocationStatus('‚ùå Location detection failed - will show fallbacks when needed', true);
      }
    });
    
    // Scroll Indicator Logic
    let scrollIndicatorTimeout;
    
    function showScrollIndicator() {
      const indicator = document.getElementById('scroll-indicator');
      const output = document.getElementById('output');
      
      // Only show if there are results and content is below the fold
      if (output && output.children.length > 0) {
        const outputRect = output.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
        // If output extends beyond viewport, show indicator
        if (outputRect.bottom > windowHeight) {
          indicator.classList.add('visible');
          
          // Auto-hide after 3 seconds
          clearTimeout(scrollIndicatorTimeout);
          scrollIndicatorTimeout = setTimeout(() => {
            indicator.classList.remove('visible');
          }, 3000);
        }
      }
    }
    
    function hideScrollIndicator() {
      const indicator = document.getElementById('scroll-indicator');
      indicator.classList.remove('visible');
      clearTimeout(scrollIndicatorTimeout);
    }
    
    // Hide indicator on scroll
    let lastScrollTop = 0;
    window.addEventListener('scroll', () => {
      const st = window.pageYOffset || document.documentElement.scrollTop;
      
      // User scrolled down
      if (st > lastScrollTop) {
        hideScrollIndicator();
      }
      
      lastScrollTop = st <= 0 ? 0 : st;
    });
    
    // Smooth auto-scroll to results when they appear
    function smoothScrollToResults() {
      const output = document.getElementById('output');
      if (output && output.children.length > 0) {
        // Wait a bit for animations to settle
        setTimeout(() => {
          const firstCard = output.querySelector('.recommendation-card');
          if (firstCard) {
            const rect = firstCard.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            
            // Only auto-scroll on mobile if content is not fully visible
            if (window.innerWidth < 768 && rect.bottom > windowHeight * 0.8) {
              window.scrollTo({
                top: firstCard.offsetTop - 100,
                behavior: 'smooth'
              });
            }
          }
          
          // Show scroll indicator if more content below
          setTimeout(showScrollIndicator, 800);
        }, 500);
      }
    }
    
    // Override the renderResults function to trigger scroll logic
    const originalGetRecommendations = getRecommendations;
    getRecommendations = async function(...args) {
      hideScrollIndicator();
      const result = await originalGetRecommendations.apply(this, args);
      smoothScrollToResults();
      return result;
    };
  </script>
</body>
</html>

