<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>idk what to do</title>
  <link rel="stylesheet" href="style.css"/>
</head>
<body>
  <div class="container">
    <h1>In a bit of a pickle?</h1>
    <p class="subtitle">Ask me anything about food!</p>
    
    <div class="input-box">
      <input id="input" placeholder="e.g. nearby cafe with cheap but good food" onkeypress="handleKeyPress(event)"/>
      <button onclick="getRecommendations()" class="search-button">
        <span class="button-text">Search</span>
        <span class="button-icon">🔍</span>
      </button>
    </div>
    
    <div class="location-box">
      <span id="location-status" class="location-status">📍 Getting your location...</span>
    </div>
    
    <div class="filter-sticky-wrapper">
      <div class="quick-actions">
      <button id="super-nearby-toggle" onclick="toggleFilter('super-nearby')" class="quick-btn super-nearby off">
        <span class="btn-icon">🚶‍♂️</span>
        <span class="btn-text">Super Nearby</span>
        <span class="btn-subtitle">300m</span>
      </button>
      <button onclick="quickSearch('surprise-me')" class="quick-btn surprise-me">
        <span class="btn-icon">😈</span>
        <span class="btn-text">Surprise Me</span>
        <span class="btn-subtitle">Random 4.5+</span>
      </button>
      <button id="imma-walk-toggle" onclick="toggleFilter('imma-walk')" class="quick-btn imma-walk off">
        <span class="btn-icon">🚶‍♀️</span>
        <span class="btn-text">Imma Walk</span>
        <span class="btn-subtitle">500m</span>
      </button>
      <button id="price-toggle" onclick="togglePriceMode()" class="quick-btn price-toggle off">
        <span class="btn-icon">💰</span>
        <span class="btn-text">Any Price</span>
        <span class="btn-subtitle">No filter</span>
      </button>
      </div>
    </div>
    
    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scroll-indicator">
      <span>More results below</span>
      <span class="arrow">↓</span>
    </div>
    
    <!-- Modern Group Voting Modal -->
    <div class="group-voting-overlay" id="group-voting" style="display: none;" onclick="closeGroupVotingIfOverlay(event)">
      <div class="group-voting-modal">
        <div class="voting-header">
          <h3>🗳️ Group Voting</h3>
          <button onclick="closeGroupVoting()" class="close-btn">×</button>
        </div>
        
        <!-- Step 1: Group Size -->
        <div class="voting-step" id="voting-step-1">
          <div class="voting-content">
            <div class="group-size-selector">
              <label>How many people are voting?</label>
              <div class="number-input-container">
                <button onclick="decreaseGroupSize()" class="number-btn">−</button>
                <input type="number" id="group-size" min="2" max="20" value="4" readonly>
                <button onclick="increaseGroupSize()" class="number-btn">+</button>
              </div>
            </div>
            <button onclick="startVoting()" class="modern-btn primary">Start Voting</button>
          </div>
        </div>
        
        <!-- Step 2: Voting -->
        <div class="voting-step" id="voting-step-2" style="display: none;">
          <div class="voting-progress">
            <div class="progress-text">
              <span id="votes-count">0</span> / <span id="votes-total">4</span> votes
            </div>
            <div class="progress-bar">
              <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
          </div>
          <div class="voting-options" id="voting-options">
            <!-- Voting options will be populated here -->
          </div>
          <button onclick="revealResults()" class="modern-btn secondary reveal-btn" id="reveal-btn" style="display: none;">
            🎉 Reveal Winner
          </button>
        </div>
        
        <!-- Step 3: Results -->
        <div class="voting-step" id="voting-step-3" style="display: none;">
          <div class="winner-announcement" id="winner-announcement">
            <!-- Winner will be shown here -->
          </div>
        </div>
      </div>
    </div>
    
    <div class="group-vote-trigger" id="group-vote-trigger" style="display: none;">
      <button onclick="openGroupVoting()" class="group-vote-btn">
        <span class="btn-icon">🗳️</span>
        <span class="btn-text">Group Vote</span>
      </button>
    </div>
    
    <div id="loading-screen" class="loading-screen hidden">
      <div class="cooking-animation">
        <div class="chef-hat">👨‍🍳</div>
        <div class="cooking-text" id="cooking-text">Cooking up a fire suggestion for you...</div>
        <div class="loading-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    </div>
    
    <div id="intent-box"></div>
    <div id="output"></div>
  </div>

  <script>
    let userLocation = null;
    let currentRecommendations = [];
    let userCoordinates = null;
    let userId = null;
    let priceMode = 'off'; // 'off', 'broke', 'ballin'
    let activeFilters = {
      'super-nearby': false,
      'imma-walk': false
    };
    let groupVotingData = {
      isActive: false,
      groupSize: 4,
      votes: {},
      options: []
    };

    // Generate or retrieve user ID
    function getUserId() {
      if (!userId) {
        userId = localStorage.getItem('foodFinderUserId');
        if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('foodFinderUserId', userId);
        }
      }
      return userId;
    }

    // Track user interactions for personalization
    async function trackInteraction(interaction) {
      try {
        const response = await fetch('/interaction', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userId: getUserId(),
            ...interaction
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('✅ Interaction tracked:', data);
        }
      } catch (error) {
        console.error('❌ Failed to track interaction:', error);
      }
    }

    // Track restaurant selection
    function trackRestaurantSelection(restaurant, query, userIntent) {
      trackInteraction({
        query,
        selectedRestaurant: restaurant,
        userIntent
      });
    }

    // Track restaurant rejection
    function trackRestaurantRejection(restaurant, query, userIntent) {
      trackInteraction({
        query,
        rejectedRestaurants: [restaurant],
        userIntent
      });
    }

    // Get personalized suggestions
    async function getPersonalizedSuggestions(query = '') {
      try {
        const response = await fetch(`/suggestions/${getUserId()}?query=${encodeURIComponent(query)}`);
        if (response.ok) {
          const data = await response.json();
          return data.suggestions || [];
        }
      } catch (error) {
        console.error('❌ Failed to get personalized suggestions:', error);
      }
      return [];
    }

    // Like a restaurant
    function likeRestaurant(name, location, price, rating) {
      const restaurant = { name, location, price, rating };
      const query = document.getElementById('input').value;
      
      // Track the interaction
      trackRestaurantSelection(restaurant, query, {
        search_term: query,
        mood: 'casual',
        price_range: 'moderate'
      });
      
      // Show feedback
      showFeedback('❤️ Thanks! We\'ll remember you like this type of place!');
    }

    // Dislike a restaurant
    function dislikeRestaurant(name, location, price, rating) {
      const restaurant = { name, location, price, rating };
      const query = document.getElementById('input').value;
      
      // Track the interaction
      trackRestaurantRejection(restaurant, query, {
        search_term: query,
        mood: 'casual',
        price_range: 'moderate'
      });
      
      // Show feedback
      showFeedback('👎 Got it! We\'ll avoid similar places in the future.');
    }

    // Show feedback message
    function showFeedback(message) {
      const feedback = document.createElement('div');
      feedback.className = 'feedback-message';
      feedback.textContent = message;
      feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 1000;
        animation: slideInRight 0.3s ease-out;
      `;
      
      document.body.appendChild(feedback);
      
      setTimeout(() => {
        feedback.remove();
      }, 3000);
    }

    // Image modal functionality
    function openImageModal(imageUrl, imageAlt, photographer, allImages = null) {
      // Create modal overlay
      const modal = document.createElement('div');
      modal.className = 'image-modal-overlay';
      modal.onclick = closeImageModal;
      
      // Create modal content
      const modalContent = document.createElement('div');
      modalContent.className = 'image-modal-content';
      modalContent.onclick = (e) => e.stopPropagation();
      
      if (allImages) {
        // Show all images in a carousel
        modalContent.innerHTML = `
          <div class="modal-header">
            <h3>All Photos</h3>
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
          </div>
          <div class="modal-carousel">
            <div class="modal-carousel-container">
              ${allImages.map((img, index) => `
                <div class="modal-slide ${index === 0 ? 'active' : ''}">
                  <img src="${img.url}" alt="${img.alt || 'Restaurant photo'}" class="modal-image">
                  <div class="modal-image-credit">Official Photo</div>
                </div>
              `).join('')}
            </div>
            <div class="modal-carousel-controls">
              <button class="modal-prev" onclick="changeModalSlide(-1)">‹</button>
              <button class="modal-next" onclick="changeModalSlide(1)">›</button>
            </div>
            <div class="modal-indicators">
              ${allImages.map((_, index) => `
                <span class="modal-indicator ${index === 0 ? 'active' : ''}" onclick="goToModalSlide(${index})"></span>
              `).join('')}
            </div>
          </div>
        `;
      } else {
        // Show single image
        modalContent.innerHTML = `
          <div class="modal-header">
            <h3>${imageAlt}</h3>
            <button class="modal-close" onclick="closeImageModal()">&times;</button>
          </div>
          <div class="modal-image-container">
            <img src="${imageUrl}" alt="${imageAlt}" class="modal-image">
            <div class="modal-image-credit">Official Photo</div>
          </div>
        `;
      }
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }

    function closeImageModal() {
      const modal = document.querySelector('.image-modal-overlay');
      if (modal) {
        modal.remove();
        document.body.style.overflow = 'auto';
      }
    }

    function changeModalSlide(direction) {
      const slides = document.querySelectorAll('.modal-slide');
      const indicators = document.querySelectorAll('.modal-indicator');
      const currentActive = document.querySelector('.modal-slide.active');
      const currentIndex = Array.from(slides).indexOf(currentActive);
      
      let newIndex = currentIndex + direction;
      if (newIndex >= slides.length) newIndex = 0;
      if (newIndex < 0) newIndex = slides.length - 1;
      
      goToModalSlide(newIndex);
    }

    function goToModalSlide(index) {
      const slides = document.querySelectorAll('.modal-slide');
      const indicators = document.querySelectorAll('.modal-indicator');
      
      slides.forEach(slide => slide.classList.remove('active'));
      indicators.forEach(indicator => indicator.classList.remove('active'));
      
      if (slides[index]) slides[index].classList.add('active');
      if (indicators[index]) indicators[index].classList.add('active');
    }

    
    // Comprehensive dietary restrictions database
    const dietaryDatabase = {
      'halal': { emoji: '🕌', name: 'Halal' },
      'vegetarian': { emoji: '🥬', name: 'Vegetarian' },
      'vegan': { emoji: '🌱', name: 'Vegan' },
      'gluten-free': { emoji: '🌾', name: 'Gluten-Free' },
      'keto': { emoji: '🥑', name: 'Keto' },
      'paleo': { emoji: '🥩', name: 'Paleo' },
      'dairy-free': { emoji: '🥛', name: 'Dairy-Free' },
      'nut-free': { emoji: '🥜', name: 'Nut-Free' },
      'kosher': { emoji: '✡️', name: 'Kosher' },
      'no-eggs': { emoji: '🥚', name: 'No Eggs' },
      'low-sodium': { emoji: '🧂', name: 'Low Sodium' },
      'sugar-free': { emoji: '🍯', name: 'Sugar-Free' },
      'raw-food': { emoji: '🥕', name: 'Raw Food' },
      'pescatarian': { emoji: '🐟', name: 'Pescatarian' },
      'lactose-free': { emoji: '🥛', name: 'Lactose-Free' }
    };

    // Create price range display with money bags
    function createPriceBags(priceRange) {
      const priceLevels = {
        'budget': 1,
        'moderate': 2,
        'expensive': 4,
        'luxury': 5,
        'any': 2
      };
      
      const level = priceLevels[priceRange] || 2;
      let bags = '';
      
      for (let i = 1; i <= 5; i++) {
        const opacity = i <= level ? '1' : '0.3';
        bags += `<span class="money-bag" style="opacity: ${opacity}">💰</span>`;
      }
      
      return bags;
    }

    // Create dietary restrictions display
    function createDietaryDisplay(restrictions) {
      if (!restrictions || restrictions.length === 0) {
        return '<span class="no-restrictions">❌ None specified</span>';
      }
      
      return restrictions.map(restriction => {
        const info = dietaryDatabase[restriction.toLowerCase()];
        if (info) {
          return `<span class="dietary-tag">${info.emoji} ${info.name}</span>`;
        }
        return `<span class="dietary-tag">🥗 ${restriction}</span>`;
      }).join(' ');
    }

    // Pick for me functionality
    function pickForMe() {
      if (currentRecommendations.length === 0) {
        alert('No recommendations available to pick from!');
        return;
      }
      
      const output = document.getElementById('output');
      const cards = output.querySelectorAll('.card');
      
      // Remove previous selection highlight
      cards.forEach(card => card.classList.remove('selected'));
      
      // Pick random recommendation
      const randomIndex = Math.floor(Math.random() * currentRecommendations.length);
      const selectedCard = cards[randomIndex];
      
      // Add selection animation
      selectedCard.classList.add('selected');
      
      // Scroll to selected card
      selectedCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Show pick animation
      showPickAnimation(selectedCard);
    }

    // Show pick animation
    function showPickAnimation(card) {
      const animation = document.createElement('div');
      animation.className = 'pick-animation';
      animation.innerHTML = '🎯 Picked for you!';
      
      card.appendChild(animation);
      
      setTimeout(() => {
        animation.remove();
      }, 2000);
    }

    let loadingMessages = [
      "Cooking up a fire suggestion for you...",
      "Sifting through the best spots...",
      "Adding a pinch of local flavor...",
      "Whisking up perfect recommendations...",
      "Sautéing the finest options...",
      "Baking fresh suggestions just for you...",
      "Grilling the top picks...",
      "Simmering the perfect match...",
      "Plating your ideal recommendations...",
      "Adding the secret sauce to your search..."
    ];

    // Show loading screen with random message
    function showLoading() {
      const loadingScreen = document.getElementById('loading-screen');
      const cookingText = document.getElementById('cooking-text');
      
      // Pick a random loading message
      const randomMessage = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
      cookingText.textContent = randomMessage;
      
      loadingScreen.classList.remove('hidden');
      loadingScreen.classList.add('fade-in');
    }

    // Hide loading screen
    function hideLoading() {
      const loadingScreen = document.getElementById('loading-screen');
      loadingScreen.classList.add('hidden');
      loadingScreen.classList.remove('fade-in');
    }

    // Update location status display
    function updateLocationStatus(message, isError = false) {
      const locationStatus = document.getElementById('location-status');
      locationStatus.textContent = message;
      locationStatus.style.color = isError ? '#d32f2f' : '#2e7d32';
    }

    // Multi-step location detection with multiple fallbacks
    async function getCurrentLocation() {
      console.log('🔍 Starting multi-step location detection...');
      
      // Step 1: Try GPS with high accuracy
      try {
        const gpsLocation = await getLocationFromGPS();
        if (gpsLocation) {
          console.log('✅ GPS location successful:', gpsLocation);
          return gpsLocation;
        }
      } catch (error) {
        console.log('❌ GPS failed:', error.message);
      }
      
      // Step 2: Try GPS with lower accuracy (faster)
      try {
        const quickGpsLocation = await getLocationFromGPS(false);
        if (quickGpsLocation) {
          console.log('✅ Quick GPS location successful:', quickGpsLocation);
          return quickGpsLocation;
        }
      } catch (error) {
        console.log('❌ Quick GPS failed:', error.message);
      }
      
      // Step 3: Try cached location (if available)
      try {
        const cachedLocation = await getCachedLocation();
        if (cachedLocation) {
          console.log('✅ Cached location successful:', cachedLocation);
          return cachedLocation;
        }
      } catch (error) {
        console.log('❌ Cached location failed:', error.message);
      }
      
      // Step 4: Try IP-based location detection
      try {
        const ipLocation = await getLocationFromIP();
        if (ipLocation) {
          console.log('✅ IP-based location successful:', ipLocation);
          return ipLocation;
        }
      } catch (error) {
        console.log('❌ IP-based location failed:', error.message);
      }
      
      // Step 5: Ultimate fallback - show fallback UI
      console.log('❌ All location methods failed - showing fallbacks');
      throw new Error('All location detection methods failed');
    }

    // Step 1: GPS-based location detection
    async function getLocationFromGPS(highAccuracy = true) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }

        const options = {
          enableHighAccuracy: highAccuracy,
          timeout: highAccuracy ? 15000 : 5000, // Longer timeout for high accuracy
          maximumAge: highAccuracy ? 300000 : 60000 // 5min vs 1min cache
        };

        navigator.geolocation.getCurrentPosition(
          async (position) => {
            const { latitude, longitude } = position.coords;
            userCoordinates = { latitude, longitude };
            
            try {
              // Try Google Geocoding API first
              const response = await fetch(`/api/geocode?lat=${latitude}&lng=${longitude}`);
              const data = await response.json();
              
              if (data.results && data.results.length > 0 && data.status === 'OK') {
                const result = data.results[0];
                const locationName = extractLocationName(result);
                
                // Cache successful location
                cacheLocation(locationName, latitude, longitude);
                
                userLocation = locationName;
                updateLocationStatus(`✅ GPS: ${locationName}`);
                resolve(locationName);
              } else {
                // Use coordinates as fallback
                const coordLocation = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                userLocation = coordLocation;
                updateLocationStatus(`✅ GPS: ${coordLocation}`);
                resolve(coordLocation);
              }
            } catch (error) {
              console.error('Geocoding failed, using coordinates:', error);
              const coordLocation = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
              userLocation = coordLocation;
              updateLocationStatus(`✅ GPS: ${coordLocation}`);
              resolve(coordLocation);
            }
          },
          (error) => {
            let errorMessage = 'GPS location failed';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMessage = 'Location permission denied';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMessage = 'Location unavailable';
                break;
              case error.TIMEOUT:
                errorMessage = 'GPS timeout';
                break;
            }
            reject(new Error(errorMessage));
          },
          options
        );
      });
    }

    // Step 2: Cached location detection
    async function getCachedLocation() {
      try {
        const cached = localStorage.getItem('foodFinder_location');
        const cachedTime = localStorage.getItem('foodFinder_location_time');
        
        if (cached && cachedTime) {
          const age = Date.now() - parseInt(cachedTime);
          const maxAge = 24 * 60 * 60 * 1000; // 24 hours
          
          if (age < maxAge) {
            userLocation = cached;
            updateLocationStatus(`✅ Cached: ${cached}`);
            return cached;
          }
        }
        return null;
      } catch (error) {
        console.error('Cache access failed:', error);
        return null;
      }
    }

    // Step 3: IP-based location detection
    async function getLocationFromIP() {
      try {
        // Try multiple IP geolocation services for redundancy
        const services = [
          'https://ipapi.co/json/',
          'https://ipinfo.io/json',
          'https://api.ipgeolocation.io/ipgeo?apiKey=free'
        ];
        
        for (const service of services) {
          try {
            const response = await fetch(service, { timeout: 5000 });
            const data = await response.json();
            
            let location = null;
            console.log(`IP service ${service} returned:`, data);
            
            if (service.includes('ipapi.co')) {
              const city = data.city || 'Unknown City';
              const region = data.region || 'Unknown Region';
              const country = data.country_name || data.country || 'Unknown Country';
              location = `${city}, ${region}, ${country}`;
            } else if (service.includes('ipinfo.io')) {
              const city = data.city || 'Unknown City';
              const region = data.region || 'Unknown Region';
              const country = data.country || 'Unknown Country';
              location = `${city}, ${region}, ${country}`;
            } else if (service.includes('ipgeolocation.io')) {
              const city = data.city || 'Unknown City';
              const state = data.state_prov || 'Unknown State';
              const country = data.country_name || 'Unknown Country';
              location = `${city}, ${state}, ${country}`;
            }
            
            // Check if we got a valid location (not all "Unknown" or null values)
            if (location && 
                !location.includes('null') && 
                !location.includes('undefined') &&
                location !== 'Unknown City, Unknown Region, Unknown Country' &&
                location !== 'Current Location') {
              userLocation = location;
              updateLocationStatus(`✅ IP: ${location}`);
              cacheLocation(location);
              return location;
            } else {
              console.log(`IP service ${service} returned invalid location: ${location}`);
            }
          } catch (error) {
            console.log(`IP service ${service} failed:`, error.message);
            continue;
          }
        }
        
        // If all IP services failed, return null to trigger fallbacks
        console.log('All IP services failed - returning null to trigger fallbacks');
        return null;
      } catch (error) {
        console.error('IP location detection failed:', error);
        return null;
      }
    }

    // Helper functions
    function extractLocationName(result) {
      const components = result.address_components;
      
      let city = components.find(c => c.types.includes('locality')) || 
                components.find(c => c.types.includes('administrative_area_level_2'));
      let state = components.find(c => c.types.includes('administrative_area_level_1'));
      let country = components.find(c => c.types.includes('country'));
      
      if (city && state && country) {
        return `${city.long_name}, ${state.long_name}, ${country.long_name}`;
      } else if (city && country) {
        return `${city.long_name}, ${country.long_name}`;
      } else if (state && country) {
        return `${state.long_name}, ${country.long_name}`;
      } else {
        return result.formatted_address || 'Current Location';
      }
    }

    function cacheLocation(locationName, latitude = null, longitude = null) {
      try {
        localStorage.setItem('foodFinder_location', locationName);
        localStorage.setItem('foodFinder_location_time', Date.now().toString());
        if (latitude && longitude) {
          localStorage.setItem('foodFinder_coordinates', JSON.stringify({ latitude, longitude }));
        }
      } catch (error) {
        console.error('Failed to cache location:', error);
      }
    }

    async function getRecommendations(searchType = null) {
      const query = document.getElementById("input").value.trim();
      
      // SMART VALIDATION: Skip validation for special search types that don't need user input
      const skipValidation = searchType === 'surprise-me' || 
                             activeFilters['super-nearby'] || 
                             activeFilters['imma-walk'];
      
      // Validate input (unless special search type)
      if (!query && !skipValidation) {
        alert('Please enter what you\'re looking for!');
        return;
      }
      
      // Auto-fill query for special cases
      if (!query && skipValidation) {
        document.getElementById("input").value = 'restaurant near me';
      }
      
      // Show loading screen
      showLoading();
      
      // Clear previous results
      document.getElementById("output").innerHTML = "";
      document.getElementById("intent-box").innerHTML = "";

      // Check for network connectivity
      if (!navigator.onLine) {
        console.log('No internet connection detected');
        await showFallbackRecommendations('no_internet');
        return;
      }

      // Get user location if not already available
      if (!userLocation) {
        console.log("📍 No user location detected, trying to get location...");
        try {
          await getCurrentLocation();
          console.log("✅ Location obtained:", userLocation);
        } catch (error) {
          console.log('❌ All location methods failed:', error);
          await showFallbackRecommendations('no_location');
          return;
        }
      } else {
        console.log("📍 Using existing location:", userLocation);
      }

      try {
        // Determine search type based on active filters
        let finalSearchType = searchType;
        if (!finalSearchType) {
          if (activeFilters['super-nearby'] && activeFilters['imma-walk']) {
            finalSearchType = 'imma-walk'; // Prefer closer option
          } else if (activeFilters['super-nearby']) {
            finalSearchType = 'super-nearby';
          } else if (activeFilters['imma-walk']) {
            finalSearchType = 'imma-walk';
          }
        }

        const requestBody = { 
          query,
          userLocation: userLocation,
          searchType: finalSearchType,
          priceMode: priceMode === 'off' ? null : priceMode,
          userCoordinates: {
            ...userCoordinates,
            userId: getUserId()
          }
        };

        console.log("🚀 Sending request to /recommend with body:", requestBody);
        
        const res = await fetch("/recommend", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody)
        });

        console.log("📡 Response status:", res.status, res.statusText);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: "Unknown error" }));
          console.error("❌ Server error response:", errorData);
          
          // Handle specific error cases
          if (res.status === 400) {
            document.getElementById("output").innerHTML = `
              <div class="error-message">
                <h3>Invalid Request</h3>
                <p>${errorData.error || 'Please check your input and try again.'}</p>
                ${errorData.suggestions ? `
                  <div style="margin-top: 1rem;">
                    <p><strong>Try these instead:</strong></p>
                    <ul style="text-align: left; display: inline-block;">
                      ${errorData.suggestions.map(s => `<li>${s}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
              </div>
            `;
            return;
          }
          
          throw new Error(`Server returned ${res.status}: ${errorData.error || 'Unknown error'}`);
        }

        const data = await res.json();
        console.log("✅ Response received:", data);

        // Handle needs clarification
        if (data.intent && data.intent.needs_clarification) {
          document.getElementById("output").innerHTML = `
            <div class="clarification-container">
              <div class="clarification-header">
                <div class="clarification-emoji">🤔</div>
                <h2>I need a bit more info!</h2>
                <p>Help me understand what you're looking for:</p>
              </div>
              <div class="clarification-options">
                ${data.intent.suggested_alternatives.map(option => `
                  <button class="clarification-btn" onclick="selectClarification('${option}')">
                    ${option}
                  </button>
                `).join('')}
              </div>
            </div>
          `;
          return;
        }

        // Show parsed intent with enhanced display
        if (data.intent) {
          const priceRange = data.intent.price_range || 'any';
          const dietaryRestrictions = data.intent.dietary_restrictions || [];
          const location = data.intent.location || 'Not specified';
          const mood = data.intent.mood || 'casual';
          const confidence = data.intent.confidence || 0.8;
          
          // Create price range display with money bags
          const priceBags = createPriceBags(priceRange);
          
          // Create dietary restrictions display
          const dietaryDisplay = createDietaryDisplay(dietaryRestrictions);

          // Create mood display
          const moodEmoji = {
            'casual': '😊',
            'romantic': '💕',
            'celebration': '🎉',
            'comfort': '🤗',
            'adventure': '🌟'
          };

          document.getElementById("intent-box").innerHTML = `
            <div class="intent">
              <div class="intent-row">
                <span class="intent-label">📍 Location:</span>
                <span class="intent-value location-value">${location}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">💰 Price Range:</span>
                <span class="intent-value price-bags">${priceBags}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">🥗 Dietary:</span>
                <span class="intent-value dietary-display">${dietaryDisplay}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">${moodEmoji[mood] || '😊'} Mood:</span>
                <span class="intent-value">${mood.charAt(0).toUpperCase() + mood.slice(1)}</span>
              </div>
              <div class="intent-row">
                <span class="intent-label">🎯 Confidence:</span>
                <span class="intent-value">${Math.round(confidence * 100)}%</span>
              </div>
              ${data.metadata.sources_used ? `
                <div class="intent-row">
                  <span class="intent-label">📊 Data Sources:</span>
                  <span class="intent-value">${data.metadata.sources_used.map(source => source.charAt(0).toUpperCase() + source.slice(1)).join(', ')}</span>
                </div>
                <div class="intent-row">
                  <span class="intent-label">🔍 Results Found:</span>
                  <span class="intent-value">${data.metadata.source_counts ? Object.entries(data.metadata.source_counts).map(([source, count]) => `${source.charAt(0).toUpperCase() + source.slice(1)}: ${count}`).join(', ') : 'N/A'}</span>
                </div>
              ` : ''}
            </div>
          `;
        }
        
        // Handle no results
        if (!data.recommendations || data.recommendations.length === 0) {
          console.log("❌ No recommendations found");
          document.getElementById("output").innerHTML = `
            <div class="no-results-container">
              <div class="no-results-header">
                <div class="no-results-emoji">🔍</div>
                <h2>No results found</h2>
                <p>Try adjusting your search or filters</p>
              </div>
              <div class="no-results-suggestions">
                <button class="suggestion-btn" onclick="broadenSearch()">
                  <span class="suggestion-icon">🔍</span>
                  <span class="suggestion-text">Broaden Search</span>
                </button>
                <button class="suggestion-btn" onclick="clearFilters()">
                  <span class="suggestion-icon">🔄</span>
                  <span class="suggestion-text">Clear Filters</span>
                </button>
              </div>
            </div>
          `;
          return;
        }
        
        console.log("✅ Recommendations found, proceeding to render");

        // Store recommendations for pick for me functionality
        currentRecommendations = data.recommendations;
        
        try {
          renderResults(data.recommendations);
          console.log("Successfully rendered results");
        } catch (renderError) {
          console.error("Error in renderResults:", renderError);
          throw renderError;
        }

      } catch (err) {
        console.error("Error in getRecommendations:", err);
        
        // Check if it's a network error or API failure
        if (!navigator.onLine || err.message.includes('fetch') || err.message.includes('Failed to fetch')) {
          await showFallbackRecommendations('network_error');
        } else {
          document.getElementById("output").innerHTML = `
            <div class="error-message">
              <h3>Oops! Something went wrong</h3>
              <p>Please try again or check your internet connection.</p>
              <p style="font-size: 0.8rem; color: #666;">Error: ${err.message}</p>
              <button onclick="getRecommendations()" class="retry-btn">Try Again</button>
            </div>
          `;
        }
      } finally {
        // Hide loading screen
        hideLoading();
      }
    }

    function renderResults(results) {
      if (!Array.isArray(results)) results = [results];

      // Add pick for me button
      const pickButton = `
        <div class="pick-for-me-container">
          <button onclick="pickForMe()" class="pick-for-me-btn">
            <span class="dice-emoji">🎲</span>
            <span class="pick-text">Pick for Me!</span>
          </button>
        </div>
      `;

      const resultsHTML = results.map(r => `
        <div class="card">
          <div class="card-header">
          <h3>${r.name || "Unknown"}</h3>
            <div class="rating-badge">
              ${r.rating ? `<span class="stars">${'⭐'.repeat(Math.floor(r.rating))}</span> ${r.rating}/5` : ""}
              ${r.user_ratings_total ? `<span class="review-count">(${r.user_ratings_total} reviews)</span>` : ""}
            </div>
          </div>
          ${r.images && r.images.length > 0 ? `
            <div class="restaurant-images-gallery">
              <div class="gallery-container">
                ${r.images.slice(0, 4).map((img, index) => `
                  <div class="gallery-item ${index === 0 ? 'featured' : ''}" onclick="openImageModal('${img.url}', '${img.alt || r.name}', '')">
                    <img src="${img.url}" alt="${img.alt || r.name}" class="gallery-image" loading="lazy" 
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="image-placeholder" style="display: none; align-items: center; justify-content: center; background: #f5f5f5; color: #666; font-size: 14px; text-align: center; padding: 20px;">
                      <div>
                        <div style="font-size: 24px; margin-bottom: 8px;">📷</div>
                        <div>${img.alt || r.name}</div>
                        <div style="font-size: 12px; margin-top: 4px;">Image unavailable</div>
                      </div>
                    </div>
                    <div class="image-credit">Official Photo</div>
                  </div>
                `).join('')}
                ${r.images.length > 4 ? `<div class="more-photos" onclick="openImageModal('', '', '', ${JSON.stringify(r.images).replace(/"/g, '&quot;')})">+${r.images.length - 4} more</div>` : ''}
              </div>
            </div>
          ` : ''}
          <p>📍 ${r.location || "N/A"} ${r.distance_formatted ? `(${r.distance_formatted} away)` : ''}</p>
          <p>💰 ${r.price || "N/A"}</p>
          
          ${r.reason ? `
            <details class="reason">
              <summary>💡 Why this place?</summary>
              <p>${r.reason}</p>
            </details>
          ` : ""}
          
          ${r.dietary_match ? `
            <details class="reason">
              <summary>🥗 Dietary Options</summary>
              <p>${r.dietary_match}</p>
            </details>
          ` : ""}
          
          ${r.occasion_fit ? `
            <details class="reason">
              <summary>🎉 Perfect For</summary>
              <p>${r.occasion_fit}</p>
            </details>
          ` : ""}
          
          ${r.unique_selling_point ? `
            <details class="reason">
              <summary>✨ What Makes It Special</summary>
              <p>${r.unique_selling_point}</p>
            </details>
          ` : ""}
          
          ${r.low_rating_reason ? `
            <details class="reason low-rating">
              <summary>⚠️ Why We Still Recommend This</summary>
              <p>${r.low_rating_reason}</p>
            </details>
          ` : ""}
          
          <div class="restaurant-actions">
            <a href="https://www.google.com/maps/search/?api=1&query=${encodeURIComponent((r.name || "") + " " + (r.location || ""))}" 
               target="_blank" class="action-btn primary">📍 Open in Maps</a>
            <button class="action-btn like" onclick="likeRestaurant('${r.name}', '${r.location}', '${r.price}', '${r.rating}')">
              ❤️ Like
            </button>
            <button class="action-btn dislike" onclick="dislikeRestaurant('${r.name}', '${r.location}', '${r.price}', '${r.rating}')">
              👎 Dislike
            </button>
          </div>
        </div>
      `).join("");

      // Group vote button that appears after results
      const groupVoteButton = `
        <div class="group-vote-trigger" id="group-vote-results-trigger">
          <button onclick="openGroupVoting()" class="group-vote-btn">
            <span class="btn-icon">🗳️</span>
            <span class="btn-text">Group Vote</span>
          </button>
        </div>
      `;
      
      document.getElementById("output").innerHTML = pickButton + resultsHTML + groupVoteButton;
    }

    // Toggle filter function (no animation, just toggle state)
    function toggleFilter(type) {
      const button = document.getElementById(`${type}-toggle`);
      const isActive = activeFilters[type];
      
      // EXCLUSIVE TOGGLE: Super Nearby and Imma Walk are mutually exclusive
      if (type === 'super-nearby' && !isActive) {
        // Turn off Imma Walk
        if (activeFilters['imma-walk']) {
          activeFilters['imma-walk'] = false;
          const immaWalkBtn = document.getElementById('imma-walk-toggle');
          immaWalkBtn.classList.remove('active');
          immaWalkBtn.classList.add('off');
        }
      } else if (type === 'imma-walk' && !isActive) {
        // Turn off Super Nearby
        if (activeFilters['super-nearby']) {
          activeFilters['super-nearby'] = false;
          const superNearbyBtn = document.getElementById('super-nearby-toggle');
          superNearbyBtn.classList.remove('active');
          superNearbyBtn.classList.add('off');
        }
      }
      
      // Toggle the state
      activeFilters[type] = !isActive;
      
      // Update button appearance
      if (activeFilters[type]) {
        button.classList.remove('off');
        button.classList.add('active');
      } else {
        button.classList.remove('active');
        button.classList.add('off');
      }
      
      console.log(`Filter ${type} toggled:`, activeFilters[type]);
      
      // AUTO-SEARCH: If distance filter is activated AND we have results or a query, search again
      if ((type === 'super-nearby' || type === 'imma-walk')) {
        const query = document.getElementById('input').value.trim();
        const hasResults = currentRecommendations && currentRecommendations.length > 0;
        
        // If filter is turned ON, auto-search
        if (activeFilters[type] && (query || hasResults)) {
          // Use existing query or default to last search
          const searchQuery = query || 'restaurant near me';
          document.getElementById('input').value = searchQuery;
          getRecommendations();
        }
        // If filter is turned OFF and we have results, refresh
        else if (!activeFilters[type] && hasResults && query) {
          getRecommendations();
        }
      }
    }

    // Quick search functions (only for surprise-me)
    async function quickSearch(type) {
      if (type !== 'surprise-me') return; // Only surprise-me should trigger search
      
      if (!userLocation) {
        alert('Location is still being detected. Please wait a moment and try again.');
        return;
      }

      // Set the input value
      document.getElementById('input').value = 'restaurant near me';
      
      // Show loading with custom message
      showLoading();
      const cookingText = document.getElementById('cooking-text');
      cookingText.textContent = 'Finding a random surprise for you...';

      // Make the search request with search type
      await getRecommendations(type);
    }

    // Price toggle functionality (3 states: off, broke, ballin)
    function togglePriceMode() {
      const toggle = document.getElementById('price-toggle');
      const icon = toggle.querySelector('.btn-icon');
      const text = toggle.querySelector('.btn-text');
      const subtitle = toggle.querySelector('.btn-subtitle');
      
      // Cycle through states: off -> broke -> ballin -> off
      if (priceMode === 'off') {
        priceMode = 'broke';
        icon.textContent = '💰';
        text.textContent = 'Broke';
        subtitle.textContent = '1 money bag';
        toggle.className = 'quick-btn price-toggle broke';
      } else if (priceMode === 'broke') {
        priceMode = 'ballin';
        icon.textContent = '💎';
        text.textContent = 'Ballin';
        subtitle.textContent = '5 money bags';
        toggle.className = 'quick-btn price-toggle ballin';
      } else {
        priceMode = 'off';
        icon.textContent = '💰';
        text.textContent = 'Any Price';
        subtitle.textContent = 'No filter';
        toggle.className = 'quick-btn price-toggle off';
      }
      
      // AUTO-SEARCH: If we have results, refresh with new price filter
      const query = document.getElementById('input').value.trim();
      const hasResults = currentRecommendations && currentRecommendations.length > 0;
      
      if (hasResults && query) {
        getRecommendations();
      }
    }

    // Group voting functions
    function openGroupVoting() {
      if (currentRecommendations.length === 0) {
        showToast('Please get some recommendations first!', 'warning');
        return;
      }
      
      document.getElementById('group-voting').style.display = 'flex';
      document.getElementById('voting-step-1').style.display = 'block';
      document.getElementById('voting-step-2').style.display = 'none';
      document.getElementById('voting-step-3').style.display = 'none';
      groupVotingData.options = currentRecommendations;
      setupVotingOptions();
    }

    function closeGroupVoting() {
      document.getElementById('group-voting').style.display = 'none';
      groupVotingData.isActive = false;
      groupVotingData.votes = {};
    }
    
    function closeGroupVotingIfOverlay(event) {
      if (event.target.classList.contains('group-voting-overlay')) {
        closeGroupVoting();
      }
    }
    
    function increaseGroupSize() {
      const input = document.getElementById('group-size');
      if (input.value < 20) input.value = parseInt(input.value) + 1;
    }
    
    function decreaseGroupSize() {
      const input = document.getElementById('group-size');
      if (input.value > 2) input.value = parseInt(input.value) - 1;
    }
    
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => toast.classList.add('show'), 10);
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    function setupVotingOptions() {
      const optionsContainer = document.getElementById('voting-options');
      optionsContainer.innerHTML = '';
      
      currentRecommendations.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'voting-option';
        optionDiv.innerHTML = `
          <div class="option-info">
            <h4>${option.name}</h4>
            <p>${option.location}</p>
            <div class="option-rating">${'⭐'.repeat(Math.floor(option.rating))} ${option.rating}/5</div>
          </div>
        `;
        optionsContainer.appendChild(optionDiv);
      });
    }

    function startVoting() {
      const groupSize = parseInt(document.getElementById('group-size').value);
      if (groupSize < 2) {
        showToast('Group size must be at least 2!', 'warning');
        return;
      }
      
      groupVotingData.groupSize = groupSize;
      groupVotingData.isActive = true;
      groupVotingData.votes = {};
      
      // Switch to voting step
      document.getElementById('voting-step-1').style.display = 'none';
      document.getElementById('voting-step-2').style.display = 'block';
      document.getElementById('votes-total').textContent = groupSize;
      document.getElementById('votes-count').textContent = '0';
      
      // Add click handlers to options
      const options = document.querySelectorAll('.voting-option');
      options.forEach((option, index) => {
        option.onclick = () => castVote(index);
        option.style.cursor = 'pointer';
      });
      
      showToast(`Pass the phone around for ${groupSize} people to vote!`, 'info');
    }

    function castVote(optionIndex) {
      if (!groupVotingData.isActive) return;
      
      // Generate anonymous voter ID
      const voterId = `voter_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Check if this device already voted (track by voting count)
      const currentVoteCount = Object.keys(groupVotingData.votes).length;
      if (currentVoteCount >= groupVotingData.groupSize) {
        showToast('All votes have been cast!', 'warning');
        return;
      }
      
      groupVotingData.votes[voterId] = optionIndex;
      
      const votedCount = Object.keys(groupVotingData.votes).length;
      
      // Update progress bar
      document.getElementById('votes-count').textContent = votedCount;
      const percentage = (votedCount / groupVotingData.groupSize) * 100;
      document.getElementById('progress-fill').style.width = percentage + '%';
      
      // Add visual feedback to voted option
      const options = document.querySelectorAll('.voting-option');
      options[optionIndex].classList.add('voted');
      setTimeout(() => options[optionIndex].classList.remove('voted'), 500);
      
      showToast(`Vote recorded! (${votedCount}/${groupVotingData.groupSize})`, 'success');
      
      // Check if all votes are in
      if (votedCount === groupVotingData.groupSize) {
        document.getElementById('reveal-btn').style.display = 'block';
        showToast('All votes are in! Ready to reveal the winner!', 'success');
      }
    }

    function revealResults() {
      if (!groupVotingData.isActive) return;
      
      // Count votes
      const voteCounts = {};
      Object.values(groupVotingData.votes).forEach(optionIndex => {
        voteCounts[optionIndex] = (voteCounts[optionIndex] || 0) + 1;
      });
      
      // Find winner
      const winnerIndex = Object.keys(voteCounts).reduce((a, b) => 
        voteCounts[a] > voteCounts[b] ? a : b
      );
      
      const winner = currentRecommendations[winnerIndex];
      const winnerVotes = voteCounts[winnerIndex];
      
      // Show winner in modal
      document.getElementById('voting-step-2').style.display = 'none';
      document.getElementById('voting-step-3').style.display = 'block';
      
      const winnerHTML = `
        <div class="confetti">🎉</div>
        <h2 class="winner-title">We have a winner!</h2>
        <div class="winner-card">
          <div class="winner-icon">🏆</div>
          <h3>${winner.name}</h3>
          <div class="winner-stats">
            <div class="stat">
              <span class="stat-label">Votes</span>
              <span class="stat-value">${winnerVotes}/${groupVotingData.groupSize}</span>
            </div>
            <div class="stat">
              <span class="stat-label">Rating</span>
              <span class="stat-value">⭐ ${winner.rating}/5</span>
            </div>
          </div>
          <p class="winner-location">📍 ${winner.location}</p>
          <p class="winner-price">💰 ${winner.price || 'N/A'}</p>
        </div>
        <button onclick="closeGroupVoting()" class="modern-btn primary">View on Map</button>
      `;
      
      document.getElementById('winner-announcement').innerHTML = winnerHTML;
      
      // Highlight winner in main results
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => card.classList.remove('group-winner'));
      if (cards[winnerIndex]) {
        cards[winnerIndex].classList.add('group-winner');
      }
      
      groupVotingData.isActive = false;
      
      // Auto-close and scroll to winner after delay
      setTimeout(() => {
        closeGroupVoting();
        const cards = document.querySelectorAll('.card');
        if (cards[winnerIndex]) {
          cards[winnerIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 5000);
    }

    // Show conflict UI (contradictory filters)
    function showConflictUI(conflicts, suggestions) {
      const conflictHTML = `
        <div class="conflict-container">
          <div class="conflict-header">
            <div class="conflict-emoji">⚠️</div>
            <h2 class="conflict-title">Filter Conflict Detected!</h2>
            <p class="conflict-subtitle">Your filters are contradicting each other</p>
          </div>
          
          <div class="conflict-details">
            ${conflicts.map(conflict => `
              <div class="conflict-item">
                <div class="conflict-message">${conflict.message}</div>
                <div class="conflict-filters">
                  Conflicting: ${conflict.conflicting_filters.join(' vs ')}
                </div>
              </div>
            `).join('')}
          </div>
          
          <div class="suggestions-section">
            <h3>💡 Smart Suggestions:</h3>
            <div class="suggestions-list">
              ${suggestions.map(suggestion => `
                <button class="suggestion-btn" onclick="applySuggestion('${suggestion.action}', '${suggestion.new_price_mode || ''}', '${suggestion.new_search_type || ''}', '${suggestion.new_query || ''}')">
                  <span class="suggestion-icon">✨</span>
                  <span class="suggestion-text">${suggestion.message}</span>
                </button>
              `).join('')}
            </div>
          </div>
        </div>
      `;
      
      document.getElementById("output").innerHTML = conflictHTML;
      document.getElementById("intent-box").innerHTML = "";
    }
    
    // Show constraint UI (too restrictive filters)
    function showConstraintUI(constraints, suggestions, metadata) {
      const constraintHTML = `
        <div class="constraint-container">
          <div class="constraint-header">
            <div class="constraint-emoji">🔍</div>
            <h2 class="constraint-title">Filters Too Restrictive!</h2>
            <p class="constraint-subtitle">Found ${metadata.total_found} places, but none match your strict filters</p>
          </div>
          
          <div class="constraint-details">
            <h3>🚫 What's limiting your results:</h3>
            ${constraints.map(constraint => `
              <div class="constraint-item ${constraint.severity}">
                <div class="constraint-message">${constraint.message}</div>
                <div class="constraint-impact">${constraint.impact}</div>
              </div>
            `).join('')}
          </div>
          
          <div class="suggestions-section">
            <h3>💡 Try these adjustments:</h3>
            <div class="suggestions-list">
              ${suggestions.map(suggestion => `
                <button class="suggestion-btn" onclick="applySuggestion('${suggestion.action}', '${suggestion.new_price_mode || ''}', '${suggestion.new_search_type || ''}', '${suggestion.new_query || ''}')">
                  <span class="suggestion-icon">🎯</span>
                  <span class="suggestion-text">${suggestion.message}</span>
                </button>
              `).join('')}
            </div>
          </div>
        </div>
      `;
      
      document.getElementById("output").innerHTML = constraintHTML;
      document.getElementById("intent-box").innerHTML = "";
    }
    
    // Apply suggestion (adjust filters and re-search)
    function applySuggestion(action, newPriceMode, newSearchType, newQuery) {
      console.log("Applying suggestion:", { action, newPriceMode, newSearchType, newQuery });
      
      // Update price mode
      if (newPriceMode && newPriceMode !== '') {
        priceMode = newPriceMode;
        updatePriceToggleUI();
      }
      
      // Update search type (toggle filters)
      if (newSearchType && newSearchType !== '') {
        // Turn off current filters
        activeFilters['super-nearby'] = false;
        activeFilters['imma-walk'] = false;
        updateFilterUI();
        
        // Turn on new filter
        if (newSearchType === 'super-nearby') {
          activeFilters['super-nearby'] = true;
        } else if (newSearchType === 'imma-walk') {
          activeFilters['imma-walk'] = true;
        }
        updateFilterUI();
      } else if (newSearchType === null) {
        // Turn off all distance filters
        activeFilters['super-nearby'] = false;
        activeFilters['imma-walk'] = false;
        updateFilterUI();
      }
      
      // Update query if provided
      if (newQuery && newQuery !== '') {
        document.getElementById('input').value = newQuery;
      }
      
      // Re-search with new settings
      getRecommendations();
    }
    
    // Update price toggle UI
    function updatePriceToggleUI() {
      const toggle = document.getElementById('price-toggle');
      const icon = toggle.querySelector('.btn-icon');
      const text = toggle.querySelector('.btn-text');
      const subtitle = toggle.querySelector('.btn-subtitle');
      
      if (priceMode === 'broke') {
        icon.textContent = '💰';
        text.textContent = 'Broke';
        subtitle.textContent = '1 money bag';
        toggle.className = 'quick-btn price-toggle broke';
      } else if (priceMode === 'ballin') {
        icon.textContent = '💎';
        text.textContent = 'Ballin';
        subtitle.textContent = '5 money bags';
        toggle.className = 'quick-btn price-toggle ballin';
      } else {
        icon.textContent = '💰';
        text.textContent = 'Any Price';
        subtitle.textContent = 'No filter';
        toggle.className = 'quick-btn price-toggle off';
      }
    }
    
    // Update filter UI
    function updateFilterUI() {
      // Update super-nearby
      const superNearbyBtn = document.getElementById('super-nearby-toggle');
      if (activeFilters['super-nearby']) {
        superNearbyBtn.classList.remove('off');
        superNearbyBtn.classList.add('active');
      } else {
        superNearbyBtn.classList.remove('active');
        superNearbyBtn.classList.add('off');
      }
      
      // Update imma-walk
      const immaWalkBtn = document.getElementById('imma-walk-toggle');
      if (activeFilters['imma-walk']) {
        immaWalkBtn.classList.remove('off');
        immaWalkBtn.classList.add('active');
      } else {
        immaWalkBtn.classList.remove('active');
        immaWalkBtn.classList.add('off');
      }
    }

    // Show fallback recommendations with special UI
    async function showFallbackRecommendations(reason) {
      hideLoading();
      
      try {
        const response = await fetch('/api/fallback');
        const data = await response.json();
        
        // Show special fallback UI
        const fallbackHTML = `
          <div class="fallback-container">
            <div class="fallback-header">
              <div class="fallback-emoji">😱</div>
              <h2 class="fallback-title">It seems your location cannot be detected!</h2>
              <p class="fallback-subtitle">These are some of Caleb's favorites instead!</p>
            </div>
            <div class="fallback-recommendations">
              ${data.recommendations.map(r => `
                <div class="card fallback-card">
                  <div class="card-header">
                    <h3>${r.name}</h3>
                    <div class="rating-badge">
                      <span class="stars">⭐</span>
                      <span class="rating">${r.rating}</span>
                    </div>
                  </div>
                  <div class="card-body">
                    <p class="location">📍 ${r.location}</p>
                    <p class="price">💰 ${r.price}</p>
                    <p class="reason">${r.reason}</p>
                    <div class="fallback-badge">Caleb's Pick</div>
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="fallback-footer">
              <p>💡 Try enabling location services or check your internet connection for better recommendations!</p>
            </div>
          </div>
        `;
        
        document.getElementById("output").innerHTML = fallbackHTML;
        
        // Clear intent box for fallback
        document.getElementById("intent-box").innerHTML = "";
        
      } catch (error) {
        console.error('Fallback failed:', error);
        document.getElementById("output").innerHTML = `
          <div class="error-message">
            <h3>😔 Sorry, we're having technical difficulties</h3>
            <p>Please check your internet connection and try again later.</p>
          </div>
        `;
      }
    }

    // Helper functions for new UI elements
    function selectClarification(option) {
      document.getElementById('input').value = option;
      getRecommendations();
    }
    
    function broadenSearch() {
      // Clear all filters
      activeFilters['super-nearby'] = false;
      activeFilters['imma-walk'] = false;
      priceMode = 'off';
      updateFilterUI();
      updatePriceToggleUI();
      
      // Get current query and make it more general
      const currentQuery = document.getElementById('input').value;
      const broadenedQuery = broadenQuery(currentQuery);
      document.getElementById('input').value = broadenedQuery;
      
      getRecommendations();
    }
    
    function clearFilters() {
      // Clear all filters
      activeFilters['super-nearby'] = false;
      activeFilters['imma-walk'] = false;
      priceMode = 'off';
      updateFilterUI();
      updatePriceToggleUI();
      
      getRecommendations();
    }
    
    function broadenQuery(query) {
      const broadeners = [
        'restaurant near me',
        'good food near me',
        'food near me',
        'restaurant',
        'food'
      ];
      
      // If query is very specific, make it more general
      if (query.length > 20) {
        return broadeners[0];
      }
      
      // If query doesn't contain location words, add them
      if (!query.toLowerCase().includes('near') && !query.toLowerCase().includes('around')) {
        return query + ' near me';
      }
      
      return query;
    }

    // Handle Enter key press
    function handleKeyPress(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        getRecommendations();
      }
    }

    // Auto-get location on page load
    window.addEventListener('load', async () => {
      try {
        await getCurrentLocation();
        console.log('✅ Location detection completed successfully');
      } catch (error) {
        console.error('❌ All location methods failed:', error);
        updateLocationStatus('❌ Location detection failed - will show fallbacks when needed', true);
      }
    });
    
    // Scroll Indicator Logic
    let scrollIndicatorTimeout;
    
    function showScrollIndicator() {
      const indicator = document.getElementById('scroll-indicator');
      const output = document.getElementById('output');
      
      // Only show if there are results and content is below the fold
      if (output && output.children.length > 0) {
        const outputRect = output.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
        // If output extends beyond viewport, show indicator
        if (outputRect.bottom > windowHeight) {
          indicator.classList.add('visible');
          
          // Auto-hide after 3 seconds
          clearTimeout(scrollIndicatorTimeout);
          scrollIndicatorTimeout = setTimeout(() => {
            indicator.classList.remove('visible');
          }, 3000);
        }
      }
    }
    
    function hideScrollIndicator() {
      const indicator = document.getElementById('scroll-indicator');
      indicator.classList.remove('visible');
      clearTimeout(scrollIndicatorTimeout);
    }
    
    // Hide indicator on scroll
    let lastScrollTop = 0;
    window.addEventListener('scroll', () => {
      const st = window.pageYOffset || document.documentElement.scrollTop;
      
      // User scrolled down
      if (st > lastScrollTop) {
        hideScrollIndicator();
      }
      
      lastScrollTop = st <= 0 ? 0 : st;
    });
    
    // Smooth auto-scroll to results when they appear
    function smoothScrollToResults() {
      const output = document.getElementById('output');
      if (output && output.children.length > 0) {
        // Wait a bit for animations to settle
        setTimeout(() => {
          const firstCard = output.querySelector('.recommendation-card');
          if (firstCard) {
            const rect = firstCard.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            
            // Only auto-scroll on mobile if content is not fully visible
            if (window.innerWidth < 768 && rect.bottom > windowHeight * 0.8) {
              window.scrollTo({
                top: firstCard.offsetTop - 100,
                behavior: 'smooth'
              });
            }
          }
          
          // Show scroll indicator if more content below
          setTimeout(showScrollIndicator, 800);
        }, 500);
      }
    }
    
    // Override the renderResults function to trigger scroll logic
    const originalGetRecommendations = getRecommendations;
    getRecommendations = async function(...args) {
      hideScrollIndicator();
      const result = await originalGetRecommendations.apply(this, args);
      smoothScrollToResults();
      return result;
    };
  </script>
</body>
</html>

